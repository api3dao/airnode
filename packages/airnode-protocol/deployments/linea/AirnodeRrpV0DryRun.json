{
  "address": "0x2e768206bf5112e7D7efAf1d9df614C26475193f",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "airnode",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "requestId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "FulfilledRequest",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "requestId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "airnode",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "fulfillAddress",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "fulfillFunctionId",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "fulfill",
      "outputs": [
        {
          "internalType": "bool",
          "name": "callSuccess",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "callData",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x8e6295e87493ea7e30bed0c2c2dc0975ed50bec6ca3aa65f8bc290187727688d",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xBba33C9cB97a3eB9be85C5B9A8Da43D266d01c33",
    "contractAddress": null,
    "transactionIndex": 20,
    "gasUsed": "582904",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x331bec9f952a78cbcc2a1ef1db7ca508a5c44da578ad3d18160522bf09d7f441",
    "transactionHash": "0x8e6295e87493ea7e30bed0c2c2dc0975ed50bec6ca3aa65f8bc290187727688d",
    "logs": [],
    "blockNumber": 190251,
    "cumulativeGasUsed": "2359112",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "d8591a026515856ab7bc7dc284bf2fbe",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"FulfilledRequest\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"fulfill\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"callSuccess\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Typically, contracts are built to revert when an external call they make reverts. In contrast, AirnodeRrpV0 does not revert when the external call during the fulfillment reverts, and instead fails gracefully by emitting a `FailedRequest` event. This event signals to the future invocations of the stateless Airnode to not retry the failed fulfillment. Although this approach meets the intended purpose, it disables Airnode from calling `eth_estimateGas` on `fulfill()` to estimate the gas amount that will be used to execute a fulfillment successfully. Specifically, since `eth_estimateGas` looks for the lowest gas limit that results in the transaction not reverting, and AirnodeRrpV0's `fulfill()` does not revert when its external call reverts (because it runs out of gas), `eth_estimateGas` will not necessarily return a gas amount that will result in the fulfillment to be successful even if such an amount exists. As a solution, Airnode calls `eth_estimateGas` on AirnodeRrpV0DryRun's `fulfill()` and the external call of the fulfillment, and add these up to find the gas limit required to execute a successful fulfillment. This sum is an overestimation of the actual requirement, as it includes an additional base fee (21,000 gas on Ethereum).\",\"kind\":\"dev\",\"methods\":{\"fulfill(bytes32,address,address,bytes4,bytes,bytes)\":{\"details\":\"Refer to AirnodeRrpV0's `fulfill()` for more information\",\"params\":{\"airnode\":\"Airnode address\",\"data\":\"Fulfillment data\",\"fulfillAddress\":\"Address that will be called to fulfill\",\"fulfillFunctionId\":\"Signature of the function that will be called to fulfill\",\"requestId\":\"Request ID\"},\"returns\":{\"callData\":\"Data returned by the fulfillment call (if there is any)\",\"callSuccess\":\"If the fulfillment call succeeded\"}}},\"stateVariables\":{\"requestIdToFulfillmentParameters\":{\"details\":\"This mapping is kept as it is in AirnodeRrpV0 to closely simulate the fulfillment. All of its keys will map to zero values.\"}},\"title\":\"Contract that complements Airnode request\\u2013response protocol (RRP) to allow Airnode to estimate the gas required to execute a fulfillment\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"fulfill(bytes32,address,address,bytes4,bytes,bytes)\":{\"notice\":\"Used by Airnode to estimate the gas amount needed to fulfill the request (excluding the external call). Do not call this function, as it will have no practical effect.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/rrp/AirnodeRrpV0DryRun.sol\":\"AirnodeRrpV0DryRun\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xe9e291de7ffe06e66503c6700b1bb84ff6e0989cbb974653628d8994e7c97f03\",\"license\":\"MIT\"},\"contracts/rrp/AirnodeRrpV0DryRun.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/// @title Contract that complements Airnode request\\u2013response protocol (RRP) to\\n/// allow Airnode to estimate the gas required to execute a fulfillment\\n/// @dev Typically, contracts are built to revert when an external call they\\n/// make reverts. In contrast, AirnodeRrpV0 does not revert when the external\\n/// call during the fulfillment reverts, and instead fails gracefully by\\n/// emitting a `FailedRequest` event. This event signals to the future\\n/// invocations of the stateless Airnode to not retry the failed fulfillment.\\n/// Although this approach meets the intended purpose, it disables Airnode from\\n/// calling `eth_estimateGas` on `fulfill()` to estimate the gas amount that\\n/// will be used to execute a fulfillment successfully. Specifically, since\\n/// `eth_estimateGas` looks for the lowest gas limit that results in the\\n/// transaction not reverting, and AirnodeRrpV0's `fulfill()` does not revert\\n/// when its external call reverts (because it runs out of gas),\\n/// `eth_estimateGas` will not necessarily return a gas amount that will result\\n/// in the fulfillment to be successful even if such an amount exists.\\n/// As a solution, Airnode calls `eth_estimateGas` on AirnodeRrpV0DryRun's\\n/// `fulfill()` and the external call of the fulfillment, and add these up to\\n/// find the gas limit required to execute a successful fulfillment. This\\n/// sum is an overestimation of the actual requirement, as it includes an\\n/// additional base fee (21,000 gas on Ethereum).\\ncontract AirnodeRrpV0DryRun\\n{\\n    using ECDSA for bytes32;\\n\\n    event FulfilledRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        bytes data\\n    );\\n\\n    /// @dev This mapping is kept as it is in AirnodeRrpV0 to closely simulate\\n    /// the fulfillment. All of its keys will map to zero values.\\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\\n\\n    /// @notice Used by Airnode to estimate the gas amount needed to fulfill\\n    /// the request (excluding the external call). Do not call this function,\\n    /// as it will have no practical effect.\\n    /// @dev Refer to AirnodeRrpV0's `fulfill()` for more information\\n    /// @param requestId Request ID\\n    /// @param airnode Airnode address\\n    /// @param data Fulfillment data\\n    /// @param fulfillAddress Address that will be called to fulfill\\n    /// @param fulfillFunctionId Signature of the function that will be called\\n    /// to fulfill\\n    /// @return callSuccess If the fulfillment call succeeded\\n    /// @return callData Data returned by the fulfillment call (if there is\\n    /// any)\\n    function fulfill(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external returns (bool callSuccess, bytes memory callData) {\\n        // The line below is kept the same, except that the condition is\\n        // reversed to ensure that it never reverts. All\\n        // `requestIdToFulfillmentParameters` values are zero and virtually no\\n        // `keccak256()` output will be equal to that.\\n        require(\\n            keccak256(\\n                abi.encodePacked(\\n                    airnode,\\n                    msg.sender,\\n                    fulfillAddress,\\n                    fulfillFunctionId\\n                )\\n            ) != requestIdToFulfillmentParameters[requestId],\\n            \\\"Dummy revert string\\\"\\n        );\\n        // The line below does not need to be modified\\n        require(\\n            (\\n                keccak256(abi.encodePacked(requestId, data))\\n                    .toEthSignedMessageHash()\\n            ).recover(signature) == airnode,\\n            \\\"Invalid signature\\\"\\n        );\\n        // We cannot call `fulfillAddress` below because (1) we do not want\\n        // this function to actually fulfill the request (2) the fulfill\\n        // function will be behind an `onlyAirnodeRrp` modifier and will reject\\n        // the calls from AirnodeRrpV0DryRun.\\n        // Instead, we call an address that we know to not contain any\\n        // bytecode, which will result in the call to not revert or spend extra\\n        // gas. Since we have already confirmed that `airnode` has signed a\\n        // hash, it is guaranteed to be an EOA and we can use it as a dummy\\n        // call target.\\n        (callSuccess, callData) = airnode.call( // solhint-disable-line avoid-low-level-calls\\n            abi.encodeWithSelector(fulfillFunctionId, requestId, data)\\n        );\\n        // If the external call above does not succeed, the `eth_estimateGas`\\n        // called on the external call will not be able to return a gas amount.\\n        // AirnodeRrpV0DryRun's `fulfill()` optimistically estimates the\\n        // AirnodeRrpV0 overhead of a fulfillment, and expects Airnode to\\n        // detect if the external call will succeed (by calling\\n        // `eth_estimateGas` on it) independently. Therefore, we do not need to\\n        // consider the unhappy path here.\\n        if (callSuccess) {\\n            emit FulfilledRequest(airnode, requestId, data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5a3243f6e878bc2dbc853033bac3b73ba9aea70b02db49cca9a7e837cf24b170\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610997806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631decbf1814610030575b600080fd5b61004361003e366004610756565b61005a565b604051610051929190610858565b60405180910390f35b6000888152602081815260408083205490516bffffffffffffffffffffffff1960608c811b82169483019490945233841b811660348301528a841b1660488201527fffffffff000000000000000000000000000000000000000000000000000000008916605c820152820160405160208183030381529060405280519060200120141561012e5760405162461bcd60e51b815260206004820152601360248201527f44756d6d792072657665727420737472696e670000000000000000000000000060448201526064015b60405180910390fd5b886001600160a01b03166101f085858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506040516101ea925061018a91508f908c908c90602001610894565b60408051601f1981840301815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000084830152603c8085019190915282518085039091018152605c909301909152815191012090565b90610371565b6001600160a01b0316146102465760405162461bcd60e51b815260206004820152601160248201527f496e76616c6964207369676e61747572650000000000000000000000000000006044820152606401610125565b886001600160a01b0316878b8888604051602401610266939291906108d7565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925290516102d191906108fa565b6000604051808303816000865af19150503d806000811461030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b50909250905081156103645789896001600160a01b03167fc0977dab79883641ece94bb6a932ca83049f561ffff8d8daaeafdbc1acce9e0a888860405161035b929190610916565b60405180910390a35b9850989650505050505050565b60008060006103808585610395565b9150915061038d81610405565b509392505050565b6000808251604114156103cc5760208301516040840151606085015160001a6103c0878285856105c3565b945094505050506103fe565b8251604014156103f657602083015160408401516103eb8683836106b0565b9350935050506103fe565b506000905060025b9250929050565b600081600481111561041957610419610932565b14156104225750565b600181600481111561043657610436610932565b14156104845760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610125565b600281600481111561049857610498610932565b14156104e65760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610125565b60038160048111156104fa576104fa610932565b14156105535760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610125565b600481600481111561056757610567610932565b14156105c05760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610125565b50565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156105fa57506000905060036106a7565b8460ff16601b1415801561061257508460ff16601c14155b1561062357506000905060046106a7565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610677573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166106a0576000600192509250506106a7565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831660ff84901c601b016106ea878288856105c3565b935093505050935093915050565b80356001600160a01b038116811461070f57600080fd5b919050565b60008083601f84011261072657600080fd5b50813567ffffffffffffffff81111561073e57600080fd5b6020830191508360208285010111156103fe57600080fd5b60008060008060008060008060c0898b03121561077257600080fd5b8835975061078260208a016106f8565b965061079060408a016106f8565b955060608901357fffffffff00000000000000000000000000000000000000000000000000000000811681146107c557600080fd5b9450608089013567ffffffffffffffff808211156107e257600080fd5b6107ee8c838d01610714565b909650945060a08b013591508082111561080757600080fd5b506108148b828c01610714565b999c989b5096995094979396929594505050565b60005b8381101561084357818101518382015260200161082b565b83811115610852576000848401525b50505050565b8215158152604060208201526000825180604084015261087f816060850160208701610828565b601f01601f1916919091016060019392505050565b838152818360208301376000910160200190815292915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8381526040602082015260006108f16040830184866108ae565b95945050505050565b6000825161090c818460208701610828565b9190910192915050565b60208152600061092a6020830184866108ae565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fdfea26469706673582212201f6f9d6bb1fa5e17ffc6a138eebeb4fdd93d3c2b7fe4bcc141ddae7c7708cb6464736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631decbf1814610030575b600080fd5b61004361003e366004610756565b61005a565b604051610051929190610858565b60405180910390f35b6000888152602081815260408083205490516bffffffffffffffffffffffff1960608c811b82169483019490945233841b811660348301528a841b1660488201527fffffffff000000000000000000000000000000000000000000000000000000008916605c820152820160405160208183030381529060405280519060200120141561012e5760405162461bcd60e51b815260206004820152601360248201527f44756d6d792072657665727420737472696e670000000000000000000000000060448201526064015b60405180910390fd5b886001600160a01b03166101f085858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506040516101ea925061018a91508f908c908c90602001610894565b60408051601f1981840301815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000084830152603c8085019190915282518085039091018152605c909301909152815191012090565b90610371565b6001600160a01b0316146102465760405162461bcd60e51b815260206004820152601160248201527f496e76616c6964207369676e61747572650000000000000000000000000000006044820152606401610125565b886001600160a01b0316878b8888604051602401610266939291906108d7565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925290516102d191906108fa565b6000604051808303816000865af19150503d806000811461030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b50909250905081156103645789896001600160a01b03167fc0977dab79883641ece94bb6a932ca83049f561ffff8d8daaeafdbc1acce9e0a888860405161035b929190610916565b60405180910390a35b9850989650505050505050565b60008060006103808585610395565b9150915061038d81610405565b509392505050565b6000808251604114156103cc5760208301516040840151606085015160001a6103c0878285856105c3565b945094505050506103fe565b8251604014156103f657602083015160408401516103eb8683836106b0565b9350935050506103fe565b506000905060025b9250929050565b600081600481111561041957610419610932565b14156104225750565b600181600481111561043657610436610932565b14156104845760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610125565b600281600481111561049857610498610932565b14156104e65760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610125565b60038160048111156104fa576104fa610932565b14156105535760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610125565b600481600481111561056757610567610932565b14156105c05760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610125565b50565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156105fa57506000905060036106a7565b8460ff16601b1415801561061257508460ff16601c14155b1561062357506000905060046106a7565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610677573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166106a0576000600192509250506106a7565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831660ff84901c601b016106ea878288856105c3565b935093505050935093915050565b80356001600160a01b038116811461070f57600080fd5b919050565b60008083601f84011261072657600080fd5b50813567ffffffffffffffff81111561073e57600080fd5b6020830191508360208285010111156103fe57600080fd5b60008060008060008060008060c0898b03121561077257600080fd5b8835975061078260208a016106f8565b965061079060408a016106f8565b955060608901357fffffffff00000000000000000000000000000000000000000000000000000000811681146107c557600080fd5b9450608089013567ffffffffffffffff808211156107e257600080fd5b6107ee8c838d01610714565b909650945060a08b013591508082111561080757600080fd5b506108148b828c01610714565b999c989b5096995094979396929594505050565b60005b8381101561084357818101518382015260200161082b565b83811115610852576000848401525b50505050565b8215158152604060208201526000825180604084015261087f816060850160208701610828565b601f01601f1916919091016060019392505050565b838152818360208301376000910160200190815292915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8381526040602082015260006108f16040830184866108ae565b95945050505050565b6000825161090c818460208701610828565b9190910192915050565b60208152600061092a6020830184866108ae565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fdfea26469706673582212201f6f9d6bb1fa5e17ffc6a138eebeb4fdd93d3c2b7fe4bcc141ddae7c7708cb6464736f6c63430008090033",
  "devdoc": {
    "details": "Typically, contracts are built to revert when an external call they make reverts. In contrast, AirnodeRrpV0 does not revert when the external call during the fulfillment reverts, and instead fails gracefully by emitting a `FailedRequest` event. This event signals to the future invocations of the stateless Airnode to not retry the failed fulfillment. Although this approach meets the intended purpose, it disables Airnode from calling `eth_estimateGas` on `fulfill()` to estimate the gas amount that will be used to execute a fulfillment successfully. Specifically, since `eth_estimateGas` looks for the lowest gas limit that results in the transaction not reverting, and AirnodeRrpV0's `fulfill()` does not revert when its external call reverts (because it runs out of gas), `eth_estimateGas` will not necessarily return a gas amount that will result in the fulfillment to be successful even if such an amount exists. As a solution, Airnode calls `eth_estimateGas` on AirnodeRrpV0DryRun's `fulfill()` and the external call of the fulfillment, and add these up to find the gas limit required to execute a successful fulfillment. This sum is an overestimation of the actual requirement, as it includes an additional base fee (21,000 gas on Ethereum).",
    "kind": "dev",
    "methods": {
      "fulfill(bytes32,address,address,bytes4,bytes,bytes)": {
        "details": "Refer to AirnodeRrpV0's `fulfill()` for more information",
        "params": {
          "airnode": "Airnode address",
          "data": "Fulfillment data",
          "fulfillAddress": "Address that will be called to fulfill",
          "fulfillFunctionId": "Signature of the function that will be called to fulfill",
          "requestId": "Request ID"
        },
        "returns": {
          "callData": "Data returned by the fulfillment call (if there is any)",
          "callSuccess": "If the fulfillment call succeeded"
        }
      }
    },
    "stateVariables": {
      "requestIdToFulfillmentParameters": {
        "details": "This mapping is kept as it is in AirnodeRrpV0 to closely simulate the fulfillment. All of its keys will map to zero values."
      }
    },
    "title": "Contract that complements Airnode request–response protocol (RRP) to allow Airnode to estimate the gas required to execute a fulfillment",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "fulfill(bytes32,address,address,bytes4,bytes,bytes)": {
        "notice": "Used by Airnode to estimate the gas amount needed to fulfill the request (excluding the external call). Do not call this function, as it will have no practical effect."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3386,
        "contract": "contracts/rrp/AirnodeRrpV0DryRun.sol:AirnodeRrpV0DryRun",
        "label": "requestIdToFulfillmentParameters",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_bytes32)"
      }
    ],
    "types": {
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      }
    }
  }
}
