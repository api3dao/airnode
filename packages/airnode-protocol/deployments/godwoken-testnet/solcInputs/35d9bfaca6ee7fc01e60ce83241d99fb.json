{
  "language": "Solidity",
  "sources": {
    "contracts/access-control-registry/AccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract that allows users to manage independent, tree-shaped access\n/// control tables\n/// @notice Multiple contracts can refer to this contract to check if their\n/// users have granted accounts specific roles. Therefore, it aims to keep all\n/// access control roles of its users in this single contract.\n/// @dev Each user is called a \"manager\", and is the only member of their root\n/// role. Starting from this root role, they can create an arbitrary tree of\n/// roles and grant these to accounts. Each role has a description, and roles\n/// adminned by the same role cannot have the same description.\ncontract AccessControlRegistry is\n    Multicall,\n    AccessControl,\n    RoleDeriver,\n    IAccessControlRegistry\n{\n    /// @notice Initializes the manager by initializing its root role and\n    /// granting it to them\n    /// @dev Anyone can initialize a manager. An uninitialized manager\n    /// attempting to initialize a role will be initialized automatically.\n    /// Once a manager is initialized, subsequent initializations have no\n    /// effect.\n    /// @param manager Manager address to be initialized\n    function initializeManager(address manager) public override {\n        require(manager != address(0), \"Manager address zero\");\n        bytes32 rootRole = deriveRootRole(manager);\n        if (!hasRole(rootRole, manager)) {\n            _grantRole(rootRole, manager);\n            emit InitializedManager(rootRole, manager);\n        }\n    }\n\n    /// @notice Called by the account to renounce the role\n    /// @dev Overriden to disallow managers to renounce their root roles.\n    /// `role` and `account` are not validated because\n    /// `AccessControl.renounceRole` will revert if either of them is zero.\n    /// @param role Role to be renounced\n    /// @param account Account to renounce the role\n    function renounceRole(bytes32 role, address account)\n        public\n        override(AccessControl, IAccessControl)\n    {\n        require(\n            role != deriveRootRole(account),\n            \"role is root role of account\"\n        );\n        AccessControl.renounceRole(role, account);\n    }\n\n    /// @notice Initializes a role by setting its admin role and grants it to\n    /// the sender\n    /// @dev If the sender should not have the initialized role, they should\n    /// explicitly renounce it after initializing it.\n    /// Once a role is initialized, subsequent initializations have no effect\n    /// other than granting the role to the sender.\n    /// The sender must be a member of `adminRole`. `adminRole` value is not\n    /// validated because the sender cannot have the `bytes32(0)` role.\n    /// If the sender is an uninitialized manager that is initializing a role\n    /// directly under their root role, manager initialization will happen\n    /// automatically, which will grant the sender `adminRole` and allow them\n    /// to initialize the role.\n    /// @param adminRole Admin role to be assigned to the initialized role\n    /// @param description Human-readable description of the initialized role\n    /// @return role Initialized role\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external override returns (bytes32 role) {\n        require(bytes(description).length > 0, \"Role description empty\");\n        role = deriveRole(adminRole, description);\n        // AccessControl roles have `DEFAULT_ADMIN_ROLE` (i.e., `bytes32(0)`)\n        // as their `adminRole` by default. No account in AccessControlRegistry\n        // can possibly have that role, which means all initialized roles will\n        // have non-default admin roles, and vice versa.\n        if (getRoleAdmin(role) == DEFAULT_ADMIN_ROLE) {\n            if (adminRole == deriveRootRole(_msgSender())) {\n                initializeManager(_msgSender());\n            }\n            _setRoleAdmin(role, adminRole);\n            emit InitializedRole(role, adminRole, description, _msgSender());\n        }\n        grantRole(role, _msgSender());\n    }\n\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function deriveRootRole(address manager)\n        public\n        pure\n        override\n        returns (bytes32 rootRole)\n    {\n        rootRole = _deriveRootRole(manager);\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Human-readable description of the role\n    /// @return role Role\n    function deriveRole(bytes32 adminRole, string calldata description)\n        public\n        pure\n        override\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, description);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/access-control-registry/RoleDeriver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will derive\n/// AccessControlRegistry roles\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\n/// derive roles, it should inherit this contract instead of re-implementing\n/// the logic\ncontract RoleDeriver {\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function _deriveRootRole(address manager)\n        internal\n        pure\n        returns (bytes32 rootRole)\n    {\n        rootRole = keccak256(abi.encodePacked(manager));\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Human-readable description of the role\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, string memory description)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\n    }\n\n    /// @notice Derives the role using its admin role and description hash\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param descriptionHash Hash of the human-readable description of the\n    /// role\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, bytes32 descriptionHash)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ninterface IAccessControlRegistry is IAccessControl {\n    event InitializedManager(bytes32 indexed rootRole, address indexed manager);\n\n    event InitializedRole(\n        bytes32 indexed role,\n        bytes32 indexed adminRole,\n        string description,\n        address sender\n    );\n\n    function initializeManager(address manager) external;\n\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external returns (bytes32 role);\n\n    function deriveRootRole(address manager)\n        external\n        pure\n        returns (bytes32 rootRole);\n\n    function deriveRole(bytes32 adminRole, string calldata description)\n        external\n        pure\n        returns (bytes32 role);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/whitelist/WhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./WhitelistRoles.sol\";\nimport \"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./interfaces/IWhitelistRolesWithManager.sol\";\nimport \"../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// roles where there is a single manager\ncontract WhitelistRolesWithManager is\n    WhitelistRoles,\n    AccessControlRegistryAdminnedWithManager,\n    IWhitelistRolesWithManager\n{\n    // Since there will be a single manager, we can derive the roles beforehand\n\n    /// @notice Whitelist expiration extender role\n    bytes32 public immutable override whitelistExpirationExtenderRole;\n\n    /// @notice Whitelist expiration setter role\n    bytes32 public immutable override whitelistExpirationSetterRole;\n\n    /// @notice Indefinite whitelister role\n    bytes32 public immutable override indefiniteWhitelisterRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        whitelistExpirationExtenderRole = _deriveRole(\n            adminRole,\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\n        );\n        whitelistExpirationSetterRole = _deriveRole(\n            adminRole,\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\n        );\n        indefiniteWhitelisterRole = _deriveRole(\n            adminRole,\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @dev Returns if the account has the whitelist expiration extender role\n    /// or is the manager\n    /// @param account Account address\n    /// @return If the account has the whitelist extender role or is the\n    /// manager\n    function hasWhitelistExpirationExtenderRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                whitelistExpirationExtenderRole,\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the whitelist expriation setter role or\n    /// is the manager\n    /// @param account Account address\n    /// @return If the account has the whitelist setter role or is the\n    /// manager\n    function hasWhitelistExpirationSetterRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                whitelistExpirationSetterRole,\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the indefinite whitelister role or is the\n    /// manager\n    /// @param account Account address\n    /// @return If the account has the indefinite whitelister role or is the\n    /// manager\n    function hasIndefiniteWhitelisterRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                indefiniteWhitelisterRole,\n                account\n            );\n    }\n}\n"
    },
    "contracts/whitelist/WhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IWhitelistRoles.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// generic AccessControlRegistry roles\ncontract WhitelistRoles is IWhitelistRoles {\n    // There are four roles implemented in this contract:\n    // Root\n    // └── (1) Admin (can grant and revoke the roles below)\n    //     ├── (2) Whitelist expiration extender\n    //     ├── (3) Whitelist expiration setter\n    //     └── (4) Indefinite whitelister\n    // Their IDs are derived from the descriptions below. Refer to\n    // AccessControlRegistry for more information.\n    // To clarify, the root role of the manager is the admin of (1), while (1)\n    // is the admin of (2), (3) and (4). So (1) is more of a \"contract admin\",\n    // while the `adminRole` used in AccessControl and AccessControlRegistry\n    // refers to a more general adminship relationship between roles.\n\n    /// @notice Whitelist expiration extender role description\n    string\n        public constant\n        override WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION =\n        \"Whitelist expiration extender\";\n\n    /// @notice Whitelist expiration setter role description\n    string\n        public constant\n        override WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION =\n        \"Whitelist expiration setter\";\n\n    /// @notice Indefinite whitelister role description\n\n    string public constant override INDEFINITE_WHITELISTER_ROLE_DESCRIPTION =\n        \"Indefinite whitelister\";\n\n    bytes32\n        internal constant WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION)\n        );\n\n    bytes32\n        internal constant WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION)\n        );\n\n    bytes32 internal constant INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH =\n        keccak256(abi.encodePacked(INDEFINITE_WHITELISTER_ROLE_DESCRIPTION));\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\n/// @title Contract to be inherited by contracts with manager whose adminship\n/// functionality will be implemented using AccessControlRegistry\n/// @notice The manager address here is expected to belong to an\n/// AccessControlRegistry user that is a multisig/DAO\ncontract AccessControlRegistryAdminnedWithManager is\n    AccessControlRegistryAdminned,\n    IAccessControlRegistryAdminnedWithManager\n{\n    /// @notice Address of the manager that manages the related\n    /// AccessControlRegistry roles\n    /// @dev The mutability of the manager role can be implemented by\n    /// designating an OwnableCallForwarder contract as the manager. The\n    /// ownership of this contract can then be transferred, effectively\n    /// transferring managership.\n    address public immutable override manager;\n\n    /// @notice Admin role\n    /// @dev Since `manager` is immutable, so is `adminRole`\n    bytes32 public immutable override adminRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {\n        require(_manager != address(0), \"Manager address zero\");\n        manager = _manager;\n        adminRole = _deriveAdminRole(_manager);\n    }\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRoles.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\ninterface IWhitelistRolesWithManager is\n    IWhitelistRoles,\n    IAccessControlRegistryAdminnedWithManager\n{\n    function whitelistExpirationExtenderRole() external view returns (bytes32);\n\n    function whitelistExpirationSetterRole() external view returns (bytes32);\n\n    function indefiniteWhitelisterRole() external view returns (bytes32);\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWhitelistRoles {\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./AccessControlRegistryUser.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminned.sol\";\n\n/// @title Contract to be inherited by contracts whose adminship functionality\n/// will be implemented using AccessControlRegistry\ncontract AccessControlRegistryAdminned is\n    Multicall,\n    RoleDeriver,\n    AccessControlRegistryUser,\n    IAccessControlRegistryAdminned\n{\n    /// @notice Admin role description\n    string public override adminRoleDescription;\n\n    bytes32 internal immutable adminRoleDescriptionHash;\n\n    /// @dev Contracts deployed with the same admin role descriptions will have\n    /// the same roles, meaning that granting an account a role will authorize\n    /// it in multiple contracts. Unless you want your deployed contract to\n    /// share the role configuration of another contract, use a unique admin\n    /// role description.\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    ) AccessControlRegistryUser(_accessControlRegistry) {\n        require(\n            bytes(_adminRoleDescription).length > 0,\n            \"Admin role description empty\"\n        );\n        adminRoleDescription = _adminRoleDescription;\n        adminRoleDescriptionHash = keccak256(\n            abi.encodePacked(_adminRoleDescription)\n        );\n    }\n\n    /// @notice Derives the admin role for the specific manager address\n    /// @param manager Manager address\n    /// @return adminRole Admin role\n    function _deriveAdminRole(address manager)\n        internal\n        view\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveRole(\n            _deriveRootRole(manager),\n            adminRoleDescriptionHash\n        );\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryAdminned.sol\";\n\ninterface IAccessControlRegistryAdminnedWithManager is\n    IAccessControlRegistryAdminned\n{\n    function manager() external view returns (address);\n\n    function adminRole() external view returns (bytes32);\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccessControlRegistry.sol\";\nimport \"./interfaces/IAccessControlRegistryUser.sol\";\n\n/// @title Contract to be inherited by contracts that will interact with\n/// AccessControlRegistry\ncontract AccessControlRegistryUser is IAccessControlRegistryUser {\n    /// @notice AccessControlRegistry contract address\n    address public immutable override accessControlRegistry;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    constructor(address _accessControlRegistry) {\n        require(_accessControlRegistry != address(0), \"ACR address zero\");\n        accessControlRegistry = _accessControlRegistry;\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryUser.sol\";\n\ninterface IAccessControlRegistryAdminned is IAccessControlRegistryUser {\n    function adminRoleDescription() external view returns (string memory);\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAccessControlRegistryUser {\n    function accessControlRegistry() external view returns (address);\n}\n"
    },
    "contracts/whitelist/WhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Whitelist.sol\";\nimport \"./WhitelistRolesWithManager.sol\";\nimport \"./interfaces/IWhitelistWithManager.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that are controlled\n/// by a manager\ncontract WhitelistWithManager is\n    Whitelist,\n    WhitelistRolesWithManager,\n    IWhitelistWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of `user` to\n    /// be able to use the service with `serviceId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsManager(msg.sender),\n            \"Cannot extend expiration\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        _extendWhitelistExpiration(serviceId, user, expirationTimestamp);\n        emit ExtendedWhitelistExpiration(\n            serviceId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `user` to be\n    /// able to use the service with `serviceId` if the sender has the\n    /// whitelist expiration setter role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsManager(msg.sender),\n            \"Cannot set expiration\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        _setWhitelistExpiration(serviceId, user, expirationTimestamp);\n        emit SetWhitelistExpiration(\n            serviceId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `user` to be able to\n    /// use the service with `serviceId` if the sender has the indefinite\n    /// whitelister role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsManager(msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            serviceId,\n            user,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            serviceId,\n            user,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsManager(setter),\n            \"setter can set indefinite status\"\n        );\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(serviceId, user, setter);\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                serviceId,\n                user,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n}\n"
    },
    "contracts/whitelist/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that need temporary and\n/// permanent whitelists for services identified by hashes\n/// @notice This contract implements two kinds of whitelisting:\n///   (1) Temporary, ends when the expiration timestamp is in the past\n///   (2) Indefinite, ends when the indefinite whitelist count is zero\n/// Multiple senders can indefinitely whitelist/unwhitelist independently. The\n/// user will be considered whitelisted as long as there is at least one active\n/// indefinite whitelisting.\n/// @dev The interface of this contract is not implemented. It should be\n/// inherited and its functions should be exposed with a sort of an\n/// authorization scheme.\ncontract Whitelist {\n    struct WhitelistStatus {\n        uint64 expirationTimestamp;\n        uint192 indefiniteWhitelistCount;\n    }\n\n    mapping(bytes32 => mapping(address => WhitelistStatus))\n        internal serviceIdToUserToWhitelistStatus;\n\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\n        internal serviceIdToUserToSetterToIndefiniteWhitelistStatus;\n\n    /// @notice Extends the expiration of the temporary whitelist of the user\n    /// for the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        require(\n            expirationTimestamp >\n                serviceIdToUserToWhitelistStatus[serviceId][user]\n                    .expirationTimestamp,\n            \"Does not extend expiration\"\n        );\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of the user for\n    /// the service\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the indefinite whitelist status of the user for the\n    /// service\n    /// @dev As long as at least there is at least one account that has set the\n    /// indefinite whitelist status of the user for the service as true, the\n    /// user will be considered whitelisted\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) internal returns (uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            status &&\n            !serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][\n                user\n            ][msg.sender]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = true;\n            indefiniteWhitelistCount++;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        } else if (\n            !status &&\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        }\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to the user for\n    /// the service by a specific account\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) internal returns (bool revoked, uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n            revoked = true;\n        }\n    }\n\n    /// @notice Returns if the user is whitelised to use the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(bytes32 serviceId, address user)\n        internal\n        view\n        returns (bool isWhitelisted)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                serviceId\n            ][user];\n        return\n            whitelistStatus.indefiniteWhitelistCount > 0 ||\n            whitelistStatus.expirationTimestamp > block.timestamp;\n    }\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRolesWithManager.sol\";\n\ninterface IWhitelistWithManager is IWhitelistRolesWithManager {\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external;\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistRolesWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRoles.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\";\n\ninterface IWhitelistRolesWithAirnode is\n    IWhitelistRoles,\n    IAccessControlRegistryAdminned\n{\n    function deriveAdminRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveWhitelistExpirationExtenderRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveWhitelistExpirationSetterRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveIndefiniteWhitelisterRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n}\n"
    },
    "contracts/whitelist/WhitelistRolesWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./WhitelistRoles.sol\";\nimport \"../access-control-registry/AccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IWhitelistRolesWithAirnode.sol\";\nimport \"../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// roles where each individual Airnode address is its own manager\ncontract WhitelistRolesWithAirnode is\n    WhitelistRoles,\n    AccessControlRegistryAdminned,\n    IWhitelistRolesWithAirnode\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {}\n\n    /// @notice Derives the admin role for the Airnode\n    /// @param airnode Airnode address\n    /// @return adminRole Admin role\n    function deriveAdminRole(address airnode)\n        external\n        view\n        override\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveAdminRole(airnode);\n    }\n\n    /// @notice Derives the whitelist expiration extender role for the Airnode\n    /// @param airnode Airnode address\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\n    /// role\n    function deriveWhitelistExpirationExtenderRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 whitelistExpirationExtenderRole)\n    {\n        whitelistExpirationExtenderRole = _deriveRole(\n            _deriveAdminRole(airnode),\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Derives the whitelist expiration setter role for the Airnode\n    /// @param airnode Airnode address\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\n    function deriveWhitelistExpirationSetterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 whitelistExpirationSetterRole)\n    {\n        whitelistExpirationSetterRole = _deriveRole(\n            _deriveAdminRole(airnode),\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Derives the indefinite whitelister role for the Airnode\n    /// @param airnode Airnode address\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\n    function deriveIndefiniteWhitelisterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 indefiniteWhitelisterRole)\n    {\n        indefiniteWhitelisterRole = _deriveRole(\n            _deriveAdminRole(airnode),\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @dev Returns if the account has the whitelist expiration extender role\n    /// or is the Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    /// @return If the account has the whitelist extender role or is the\n    /// Airnode address\n    function hasWhitelistExpirationExtenderRoleOrIsAirnode(\n        address airnode,\n        address account\n    ) internal view returns (bool) {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveWhitelistExpirationExtenderRole(airnode),\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the whitelist expriation setter role or\n    /// is the Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    /// @return If the account has the whitelist setter role or is the Airnode\n    /// address\n    function hasWhitelistExpirationSetterRoleOrIsAirnode(\n        address airnode,\n        address account\n    ) internal view returns (bool) {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveWhitelistExpirationSetterRole(airnode),\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the indefinite whitelister role or is the\n    /// Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    /// @return If the account has the indefinite whitelister role or is the\n    /// Airnode addrss\n    function hasIndefiniteWhitelisterRoleOrIsAirnode(\n        address airnode,\n        address account\n    ) internal view returns (bool) {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveIndefiniteWhitelisterRole(airnode),\n                account\n            );\n    }\n}\n"
    },
    "contracts/utils/OwnableCallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IOwnableCallForwarder.sol\";\n\n/// @title Contract that forwards the calls that its owner sends\n/// @dev AccessControlRegistry users that want their access control tables\n/// to be transferrable (e.g., a DAO) will use this forwarder instead of\n/// interacting with it directly. There are cases where this transferrability\n/// is not desired, e.g., if the user is an Airnode and is immutably associated\n/// with a single address, in which case the manager will interact with\n/// AccessControlRegistry directly.\n/// The ownership of this contract is deliberately renouncable. If this does\n/// suit the use case, override and disable this functionality.\ncontract OwnableCallForwarder is Ownable, IOwnableCallForwarder {\n    /// @notice Forwards the calldata and the value to the target address if\n    /// the sender is the owner and returns the data\n    /// @param forwardTarget Target address that the calldata will be forwarded\n    /// to\n    /// @param forwardedCalldata Calldata to be forwarded to the target address\n    /// @return returnedData Data returned by the forwarded call\n    function forwardCall(\n        address forwardTarget,\n        bytes calldata forwardedCalldata\n    ) external payable override onlyOwner returns (bytes memory returnedData) {\n        returnedData = Address.functionCallWithValue(\n            forwardTarget,\n            forwardedCalldata,\n            msg.value\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/utils/interfaces/IOwnableCallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnableCallForwarder {\n    function forwardCall(\n        address forwardTarget,\n        bytes calldata forwardedCalldata\n    ) external payable returns (bytes memory returnedData);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/rrp/AirnodeRrpV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./AuthorizationUtilsV0.sol\";\nimport \"./TemplateUtilsV0.sol\";\nimport \"./WithdrawalUtilsV0.sol\";\nimport \"./interfaces/IAirnodeRrpV0.sol\";\n\n/// @title Contract that implements the Airnode request–response protocol (RRP)\ncontract AirnodeRrpV0 is\n    AuthorizationUtilsV0,\n    TemplateUtilsV0,\n    WithdrawalUtilsV0,\n    IAirnodeRrpV0\n{\n    using ECDSA for bytes32;\n\n    /// @notice Called to get the sponsorship status for a sponsor–requester\n    /// pair\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToRequesterToSponsorshipStatus;\n\n    /// @notice Called to get the request count of the requester plus one\n    /// @dev Can be used to calculate the ID of the next request the requester\n    /// will make\n    mapping(address => uint256) public override requesterToRequestCountPlusOne;\n\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\n    /// the fulfillment will be done with the correct parameters. This value is\n    /// also used to check if the fulfillment for the particular request is\n    /// expected, i.e., if there are recorded fulfillment parameters.\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\n\n    /// @notice Called by the sponsor to set the sponsorship status of a\n    /// requester, i.e., allow or disallow a requester to make requests that\n    /// will be fulfilled by the sponsor wallet\n    /// @dev This is not Airnode-specific, i.e., the sponsor allows the\n    /// requester's requests to be fulfilled through its sponsor wallets across\n    /// all Airnodes\n    /// @param requester Requester address\n    /// @param sponsorshipStatus Sponsorship status\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external\n        override\n    {\n        // Initialize the requester request count for consistent request gas\n        // cost\n        if (requesterToRequestCountPlusOne[requester] == 0) {\n            requesterToRequestCountPlusOne[requester] = 1;\n        }\n        sponsorToRequesterToSponsorshipStatus[msg.sender][\n            requester\n        ] = sponsorshipStatus;\n        emit SetSponsorshipStatus(msg.sender, requester, sponsorshipStatus);\n    }\n\n    /// @notice Called by the requester to make a request that refers to a\n    /// template for the Airnode address, endpoint ID and parameters\n    /// @dev `fulfillAddress` is not allowed to be the address of this\n    /// contract. This is not actually needed to protect users that use the\n    /// protocol as intended, but it is done for good measure.\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill the\n    /// request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    /// @return requestId Request ID\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external override returns (bytes32 requestId) {\n        address airnode = templates[templateId].airnode;\n        // If the Airnode address of the template is zero the template does not\n        // exist because template creation does not allow zero Airnode address\n        require(airnode != address(0), \"Template does not exist\");\n        require(fulfillAddress != address(this), \"Fulfill address AirnodeRrp\");\n        require(\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\n            \"Requester not sponsored\"\n        );\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\n            msg.sender\n        ];\n        requestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                requesterRequestCount,\n                templateId,\n                sponsor,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId,\n                parameters\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(\n                airnode,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId\n            )\n        );\n        requesterToRequestCountPlusOne[msg.sender]++;\n        emit MadeTemplateRequest(\n            airnode,\n            requestId,\n            requesterRequestCount,\n            block.chainid,\n            msg.sender,\n            templateId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by the requester to make a full request, which provides\n    /// all of its parameters as arguments and does not refer to a template\n    /// @dev `fulfillAddress` is not allowed to be the address of this\n    /// contract. This is not actually needed to protect users that use the\n    /// protocol as intended, but it is done for good measure.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    /// @return requestId Request ID\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external override returns (bytes32 requestId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(fulfillAddress != address(this), \"Fulfill address AirnodeRrp\");\n        require(\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\n            \"Requester not sponsored\"\n        );\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\n            msg.sender\n        ];\n        requestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                requesterRequestCount,\n                airnode,\n                endpointId,\n                sponsor,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId,\n                parameters\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(\n                airnode,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId\n            )\n        );\n        requesterToRequestCountPlusOne[msg.sender]++;\n        emit MadeFullRequest(\n            airnode,\n            requestId,\n            requesterRequestCount,\n            block.chainid,\n            msg.sender,\n            endpointId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by Airnode to fulfill the request (template or full)\n    /// @dev The data is ABI-encoded as a `bytes` type, with its format\n    /// depending on the request specifications.\n    /// This will not revert depending on the external call. However, it will\n    /// return `false` if the external call reverts or if there is no function\n    /// with a matching signature at `fulfillAddress`. On the other hand, it\n    /// will return `true` if the external call returns successfully or if\n    /// there is no contract deployed at `fulfillAddress`.\n    /// If `callSuccess` is `false`, `callData` can be decoded to retrieve the\n    /// revert string.\n    /// This function emits its event after an untrusted low-level call,\n    /// meaning that the order of these events within the transaction should\n    /// not be taken seriously, yet the content will be sound.\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param data Fulfillment data\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bool callSuccess, bytes memory callData) {\n        require(\n            keccak256(\n                abi.encodePacked(\n                    airnode,\n                    msg.sender,\n                    fulfillAddress,\n                    fulfillFunctionId\n                )\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        require(\n            (\n                keccak256(abi.encodePacked(requestId, data))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Invalid signature\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        (callSuccess, callData) = fulfillAddress.call( // solhint-disable-line avoid-low-level-calls\n            abi.encodeWithSelector(fulfillFunctionId, requestId, data)\n        );\n        if (callSuccess) {\n            emit FulfilledRequest(airnode, requestId, data);\n        } else {\n            // We do not bubble up the revert string from `callData`\n            emit FailedRequest(\n                airnode,\n                requestId,\n                \"Fulfillment failed unexpectedly\"\n            );\n        }\n    }\n\n    /// @notice Called by Airnode if the request cannot be fulfilled\n    /// @dev Airnode should fall back to this if a request cannot be fulfilled\n    /// because static call to `fulfill()` returns `false` for `callSuccess`\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param errorMessage A message that explains why the request has failed\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        string calldata errorMessage\n    ) external override {\n        require(\n            keccak256(\n                abi.encodePacked(\n                    airnode,\n                    msg.sender,\n                    fulfillAddress,\n                    fulfillFunctionId\n                )\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        emit FailedRequest(airnode, requestId, errorMessage);\n    }\n\n    /// @notice Called to check if the request with the ID is made but not\n    /// fulfilled/failed yet\n    /// @dev If a requester has made a request, received a request ID but did\n    /// not hear back, it can call this method to check if the Airnode has\n    /// called back `fail()` instead.\n    /// @param requestId Request ID\n    /// @return isAwaitingFulfillment If the request is awaiting fulfillment\n    /// (i.e., `true` if `fulfill()` or `fail()` is not called back yet,\n    /// `false` otherwise)\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        override\n        returns (bool isAwaitingFulfillment)\n    {\n        isAwaitingFulfillment =\n            requestIdToFulfillmentParameters[requestId] != bytes32(0);\n    }\n}\n"
    },
    "contracts/rrp/AuthorizationUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAuthorizationUtilsV0.sol\";\nimport \"../authorizers/interfaces/IAuthorizerV0.sol\";\n\n/// @title Contract that implements authorization checks\ncontract AuthorizationUtilsV0 is IAuthorizationUtilsV0 {\n    /// @notice Uses the authorizer contracts of an Airnode to decide if a\n    /// request is authorized. Once an Airnode receives a request, it calls\n    /// this method to determine if it should respond. Similarly, third parties\n    /// can use this method to determine if a particular request would be\n    /// authorized.\n    /// @dev This method is meant to be called off-chain, statically by the\n    /// Airnode to decide if it should respond to a request. The requester can\n    /// also call it, yet this function returning true should not be taken as a\n    /// guarantee of the subsequent request being fulfilled.\n    /// It is enough for only one of the authorizer contracts to return true\n    /// for the request to be authorized.\n    /// @param authorizers Authorizer contract addresses\n    /// @param airnode Airnode address\n    /// @param requestId Request ID\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return status Authorization status of the request\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) public view override returns (bool status) {\n        for (uint256 ind = 0; ind < authorizers.length; ind++) {\n            IAuthorizerV0 authorizer = IAuthorizerV0(authorizers[ind]);\n            if (\n                authorizer.isAuthorizedV0(\n                    requestId,\n                    airnode,\n                    endpointId,\n                    sponsor,\n                    requester\n                )\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice A convenience function to make multiple authorization status\n    /// checks with a single call\n    /// @param authorizers Authorizer contract addresses\n    /// @param airnode Airnode address\n    /// @param requestIds Request IDs\n    /// @param endpointIds Endpoint IDs\n    /// @param sponsors Sponsor addresses\n    /// @param requesters Requester addresses\n    /// @return statuses Authorization statuses of the request\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view override returns (bool[] memory statuses) {\n        require(\n            requestIds.length == endpointIds.length &&\n                requestIds.length == sponsors.length &&\n                requestIds.length == requesters.length,\n            \"Unequal parameter lengths\"\n        );\n        statuses = new bool[](requestIds.length);\n        for (uint256 ind = 0; ind < requestIds.length; ind++) {\n            statuses[ind] = checkAuthorizationStatus(\n                authorizers,\n                airnode,\n                requestIds[ind],\n                endpointIds[ind],\n                sponsors[ind],\n                requesters[ind]\n            );\n        }\n    }\n}\n"
    },
    "contracts/rrp/TemplateUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ITemplateUtilsV0.sol\";\n\n/// @title Contract that implements request templates\ncontract TemplateUtilsV0 is ITemplateUtilsV0 {\n    struct Template {\n        address airnode;\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    /// @notice Called to get a template\n    mapping(bytes32 => Template) public override templates;\n\n    /// @notice Creates a request template with the given parameters,\n    /// addressable by the ID it returns\n    /// @dev A specific set of request parameters will always have the same\n    /// template ID. This means a few things: (1) You can compute the expected\n    /// ID of a template before creating it, (2) Creating a new template with\n    /// the same parameters will overwrite the old one and return the same ID,\n    /// (3) After you query a template with its ID, you can verify its\n    /// integrity by applying the hash and comparing the result with the ID.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at request-time)\n    /// @return templateId Request template ID\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external override returns (bytes32 templateId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        templateId = keccak256(\n            abi.encodePacked(airnode, endpointId, parameters)\n        );\n        templates[templateId] = Template({\n            airnode: airnode,\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit CreatedTemplate(templateId, airnode, endpointId, parameters);\n    }\n\n    /// @notice A convenience method to retrieve multiple templates with a\n    /// single call\n    /// @dev Does not revert if the templates being indexed do not exist\n    /// @param templateIds Request template IDs\n    /// @return airnodes Array of Airnode addresses\n    /// @return endpointIds Array of endpoint IDs\n    /// @return parameters Array of request parameters\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        override\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        )\n    {\n        airnodes = new address[](templateIds.length);\n        endpointIds = new bytes32[](templateIds.length);\n        parameters = new bytes[](templateIds.length);\n        for (uint256 ind = 0; ind < templateIds.length; ind++) {\n            Template storage template = templates[templateIds[ind]];\n            airnodes[ind] = template.airnode;\n            endpointIds[ind] = template.endpointId;\n            parameters[ind] = template.parameters;\n        }\n    }\n}\n"
    },
    "contracts/rrp/WithdrawalUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IWithdrawalUtilsV0.sol\";\n\n/// @title Contract that implements logic for withdrawals from sponsor wallets\ncontract WithdrawalUtilsV0 is IWithdrawalUtilsV0 {\n    /// @notice Called to get the withdrawal request count of the sponsor\n    /// @dev Can be used to calculate the ID of the next withdrawal request the\n    /// sponsor will make\n    mapping(address => uint256) public override sponsorToWithdrawalRequestCount;\n\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\n    /// the fulfillment will be done with the correct parameters\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\n\n    /// @notice Called by a sponsor to create a request for the Airnode to send\n    /// the funds kept in the respective sponsor wallet to the sponsor\n    /// @dev We do not need to use the withdrawal request parameters in the\n    /// request ID hash to validate them at the node-side because all of the\n    /// parameters are used during fulfillment and will get validated on-chain.\n    /// The first withdrawal request a sponsor will make will cost slightly\n    /// higher gas than the rest due to how the request counter is implemented.\n    /// @param airnode Airnode address\n    /// @param sponsorWallet Sponsor wallet that the withdrawal is requested\n    /// from\n    function requestWithdrawal(address airnode, address sponsorWallet)\n        external\n        override\n    {\n        bytes32 withdrawalRequestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                ++sponsorToWithdrawalRequestCount[msg.sender]\n            )\n        );\n        withdrawalRequestIdToParameters[withdrawalRequestId] = keccak256(\n            abi.encodePacked(airnode, msg.sender, sponsorWallet)\n        );\n        emit RequestedWithdrawal(\n            airnode,\n            msg.sender,\n            withdrawalRequestId,\n            sponsorWallet\n        );\n    }\n\n    /// @notice Called by the Airnode using the sponsor wallet to fulfill the\n    /// withdrawal request made by the sponsor\n    /// @dev The Airnode sends the funds to the sponsor through this method\n    /// to emit an event that indicates that the withdrawal request has been\n    /// fulfilled\n    /// @param withdrawalRequestId Withdrawal request ID\n    /// @param airnode Airnode address\n    /// @param sponsor Sponsor address\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable override {\n        require(\n            withdrawalRequestIdToParameters[withdrawalRequestId] ==\n                keccak256(abi.encodePacked(airnode, sponsor, msg.sender)),\n            \"Invalid withdrawal fulfillment\"\n        );\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\n        emit FulfilledWithdrawal(\n            airnode,\n            sponsor,\n            withdrawalRequestId,\n            msg.sender,\n            msg.value\n        );\n        (bool success, ) = sponsor.call{value: msg.value}(\"\"); // solhint-disable-line avoid-low-level-calls\n        require(success, \"Transfer failed\");\n    }\n}\n"
    },
    "contracts/rrp/interfaces/IAirnodeRrpV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAuthorizationUtilsV0.sol\";\nimport \"./ITemplateUtilsV0.sol\";\nimport \"./IWithdrawalUtilsV0.sol\";\n\ninterface IAirnodeRrpV0 is\n    IAuthorizationUtilsV0,\n    ITemplateUtilsV0,\n    IWithdrawalUtilsV0\n{\n    event SetSponsorshipStatus(\n        address indexed sponsor,\n        address indexed requester,\n        bool sponsorshipStatus\n    );\n\n    event MadeTemplateRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event MadeFullRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event FulfilledRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        bytes data\n    );\n\n    event FailedRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        string errorMessage\n    );\n\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external;\n\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        string calldata errorMessage\n    ) external;\n\n    function sponsorToRequesterToSponsorshipStatus(\n        address sponsor,\n        address requester\n    ) external view returns (bool sponsorshipStatus);\n\n    function requesterToRequestCountPlusOne(address requester)\n        external\n        view\n        returns (uint256 requestCountPlusOne);\n\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        returns (bool isAwaitingFulfillment);\n}\n"
    },
    "contracts/rrp/interfaces/IAuthorizationUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAuthorizationUtilsV0 {\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool status);\n\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view returns (bool[] memory statuses);\n}\n"
    },
    "contracts/authorizers/interfaces/IAuthorizerV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAuthorizerV0 {\n    function isAuthorizedV0(\n        bytes32 requestId,\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/rrp/interfaces/ITemplateUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITemplateUtilsV0 {\n    event CreatedTemplate(\n        bytes32 indexed templateId,\n        address airnode,\n        bytes32 endpointId,\n        bytes parameters\n    );\n\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external returns (bytes32 templateId);\n\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        );\n\n    function templates(bytes32 templateId)\n        external\n        view\n        returns (\n            address airnode,\n            bytes32 endpointId,\n            bytes memory parameters\n        );\n}\n"
    },
    "contracts/rrp/interfaces/IWithdrawalUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWithdrawalUtilsV0 {\n    event RequestedWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet\n    );\n\n    event FulfilledWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet,\n        uint256 amount\n    );\n\n    function requestWithdrawal(address airnode, address sponsorWallet) external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable;\n\n    function sponsorToWithdrawalRequestCount(address sponsor)\n        external\n        view\n        returns (uint256 withdrawalRequestCount);\n}\n"
    },
    "contracts/rrp/requesters/RrpRequesterV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAirnodeRrpV0.sol\";\n\n/// @title The contract to be inherited to make Airnode RRP requests\ncontract RrpRequesterV0 {\n    IAirnodeRrpV0 public immutable airnodeRrp;\n\n    /// @dev Reverts if the caller is not the Airnode RRP contract.\n    /// Use it as a modifier for fulfill and error callback methods, but also\n    /// check `requestId`.\n    modifier onlyAirnodeRrp() {\n        require(msg.sender == address(airnodeRrp), \"Caller not Airnode RRP\");\n        _;\n    }\n\n    /// @dev Airnode RRP address is set at deployment and is immutable.\n    /// RrpRequester is made its own sponsor by default. RrpRequester can also\n    /// be sponsored by others and use these sponsorships while making\n    /// requests, i.e., using this default sponsorship is optional.\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor(address _airnodeRrp) {\n        airnodeRrp = IAirnodeRrpV0(_airnodeRrp);\n        IAirnodeRrpV0(_airnodeRrp).setSponsorshipStatus(address(this), true);\n    }\n}\n"
    },
    "contracts/rrp/requesters/RrpBeaconServerV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../../whitelist/WhitelistWithManager.sol\";\nimport \"./RrpRequesterV0.sol\";\nimport \"./interfaces/IRrpBeaconServerV0.sol\";\n\n/// @title The contract that serves beacons using Airnode RRP\n/// @notice A beacon is a live data point associated with a beacon ID, which is\n/// derived from a template ID and additional parameters. This is suitable\n/// where the more recent data point is always more favorable, e.g., in the\n/// context of an asset price data feed. Another definition of beacons are\n/// one-Airnode data feeds that can be used individually or combined to build\n/// decentralized data feeds.\n/// @dev This contract casts the reported data point to `int224`. If this is\n/// a problem (because the reported data may not fit into 224 bits or it is of\n/// a completely different type such as `bytes32`), do not use this contract\n/// and implement a customized version instead.\n/// The contract casts the timestamps to `uint32`, which means it will not work\n/// work past-2106 in the current form. If this is an issue, consider casting\n/// the timestamps to a larger type.\ncontract RrpBeaconServerV0 is\n    WhitelistWithManager,\n    RrpRequesterV0,\n    IRrpBeaconServerV0\n{\n    struct Beacon {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Returns if a sponsor has permitted an account to request\n    /// updates at this contract\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToUpdateRequesterToPermissionStatus;\n\n    mapping(bytes32 => Beacon) private beacons;\n    mapping(bytes32 => bytes32) private requestIdToBeaconId;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeRrp\n    )\n        WhitelistWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n        RrpRequesterV0(_airnodeRrp)\n    {}\n\n    /// @notice Called by the sponsor to set the update request permission\n    /// status of an account\n    /// @param updateRequester Update requester address\n    /// @param status Update permission status of the update requester\n    function setUpdatePermissionStatus(address updateRequester, bool status)\n        external\n        override\n    {\n        require(updateRequester != address(0), \"Update requester zero\");\n        sponsorToUpdateRequesterToPermissionStatus[msg.sender][\n            updateRequester\n        ] = status;\n        emit SetUpdatePermissionStatus(msg.sender, updateRequester, status);\n    }\n\n    /// @notice Called to request a beacon to be updated\n    /// @dev There are two requirements for this method to be called: (1) The\n    /// sponsor must call `setSponsorshipStatus()` of AirnodeRrp to sponsor\n    /// this RrpBeaconServer contract, (2) The sponsor must call\n    /// `setUpdatePermissionStatus()` of this RrpBeaconServer contract to give\n    /// request update permission to the caller of this method.\n    /// The template and additional parameters used here must specify a single\n    /// point of data of type `int256` and an additional timestamp of type\n    /// `uint256` to be returned because this is what `fulfill()` expects.\n    /// This point of data must be castable to `int224` and the timestamp must\n    /// be castable to `uint32`.\n    /// @param templateId Template ID of the beacon to be updated\n    /// @param sponsor Sponsor whose wallet will be used to fulfill this\n    /// request\n    /// @param sponsorWallet Sponsor wallet that will be used to fulfill this\n    /// request\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    function requestBeaconUpdate(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        bytes calldata parameters\n    ) external override {\n        require(\n            sponsorToUpdateRequesterToPermissionStatus[sponsor][msg.sender],\n            \"Caller not permitted\"\n        );\n        bytes32 beaconId = deriveBeaconId(templateId, parameters);\n        bytes32 requestId = airnodeRrp.makeTemplateRequest(\n            templateId,\n            sponsor,\n            sponsorWallet,\n            address(this),\n            this.fulfill.selector,\n            parameters\n        );\n        requestIdToBeaconId[requestId] = beaconId;\n        emit RequestedBeaconUpdate(\n            beaconId,\n            sponsor,\n            msg.sender,\n            requestId,\n            templateId,\n            sponsorWallet,\n            parameters\n        );\n    }\n\n    /// @notice Called by AirnodeRrp to fulfill the request\n    /// @dev It is assumed that the fulfillment will be made with a single\n    /// point of data of type `int256` and an additional timestamp of type\n    /// `uint256`\n    /// @param requestId ID of the request being fulfilled\n    /// @param data Fulfillment data (a single `int256` and an additional\n    /// timestamp of type `uint256` encoded as `bytes`)\n    function fulfill(bytes32 requestId, bytes calldata data)\n        external\n        override\n        onlyAirnodeRrp\n    {\n        bytes32 beaconId = requestIdToBeaconId[requestId];\n        require(beaconId != bytes32(0), \"No such request made\");\n        delete requestIdToBeaconId[requestId];\n        (int256 decodedData, uint256 decodedTimestamp) = abi.decode(\n            data,\n            (int256, uint256)\n        );\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        require(\n            decodedTimestamp <= type(uint32).max,\n            \"Timestamp typecasting error\"\n        );\n        require(\n            decodedTimestamp > beacons[beaconId].timestamp,\n            \"Fulfillment older than beacon\"\n        );\n        require(\n            decodedTimestamp + 1 hours > block.timestamp,\n            \"Fulfillment stale\"\n        );\n        require(\n            decodedTimestamp - 1 hours < block.timestamp,\n            \"Fulfillment from future\"\n        );\n        beacons[beaconId] = Beacon({\n            value: int224(decodedData),\n            timestamp: uint32(decodedTimestamp)\n        });\n        emit UpdatedBeacon(\n            beaconId,\n            requestId,\n            int224(decodedData),\n            uint32(decodedTimestamp)\n        );\n    }\n\n    /// @notice Called to read the beacon\n    /// @dev The caller must be whitelisted.\n    /// If the `timestamp` of a beacon is zero, this means that it was never\n    /// written to before, and the zero value in the `value` field is not\n    /// valid. In general, make sure to check if the timestamp of the beacon is\n    /// fresh enough, and definitely disregard beacons with zero `timestamp`.\n    /// @param beaconId ID of the beacon that will be returned\n    /// @return value Beacon value\n    /// @return timestamp Beacon timestamp\n    function readBeacon(bytes32 beaconId)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        require(\n            readerCanReadBeacon(beaconId, msg.sender),\n            \"Caller not whitelisted\"\n        );\n        Beacon storage beacon = beacons[beaconId];\n        return (beacon.value, beacon.timestamp);\n    }\n\n    /// @notice Called to check if a reader is whitelisted to read the beacon\n    /// @param beaconId Beacon ID\n    /// @param reader Reader address\n    /// @return isWhitelisted If the reader is whitelisted\n    function readerCanReadBeacon(bytes32 beaconId, address reader)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return userIsWhitelisted(beaconId, reader) || reader == address(0);\n    }\n\n    /// @notice Called to get the detailed whitelist status of the reader for\n    /// the beacon\n    /// @param beaconId Beacon ID\n    /// @param reader Reader address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// reader will expire\n    /// @return indefiniteWhitelistCount Number of times `reader` was\n    /// whitelisted indefinitely for `templateId`\n    function beaconIdToReaderToWhitelistStatus(bytes32 beaconId, address reader)\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                beaconId\n            ][reader];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted the reader\n    /// for the beacon\n    /// @param beaconId Beacon ID\n    /// @param reader Reader address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// the reader for the beacon indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted reader for the beacon\n    function beaconIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            beaconId\n        ][reader][setter];\n    }\n\n    /// @notice Derives the beacon ID from the respective template ID and\n    /// additional parameters\n    /// @param templateId Template ID\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(bytes32 templateId, bytes calldata parameters)\n        public\n        pure\n        override\n        returns (bytes32 beaconId)\n    {\n        beaconId = keccak256(abi.encodePacked(templateId, parameters));\n    }\n}\n"
    },
    "contracts/rrp/requesters/interfaces/IRrpBeaconServerV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../../whitelist/interfaces/IWhitelistWithManager.sol\";\n\ninterface IRrpBeaconServerV0 is IWhitelistWithManager {\n    event SetUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed updateRequester,\n        bool status\n    );\n\n    event RequestedBeaconUpdate(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        bytes32 templateId,\n        address sponsorWallet,\n        bytes parameters\n    );\n\n    event UpdatedBeacon(\n        bytes32 indexed beaconId,\n        bytes32 requestId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    function setUpdatePermissionStatus(address updateRequester, bool status)\n        external;\n\n    function requestBeaconUpdate(\n        bytes32 beaconId,\n        address requester,\n        address designatedWallet,\n        bytes calldata parameters\n    ) external;\n\n    function fulfill(bytes32 requestId, bytes calldata data) external;\n\n    function readBeacon(bytes32 beaconId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readerCanReadBeacon(bytes32 beaconId, address reader)\n        external\n        view\n        returns (bool);\n\n    function beaconIdToReaderToWhitelistStatus(bytes32 beaconId, address reader)\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function beaconIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function sponsorToUpdateRequesterToPermissionStatus(\n        address sponsor,\n        address updateRequester\n    ) external view returns (bool permissionStatus);\n\n    function deriveBeaconId(bytes32 templateId, bytes calldata parameters)\n        external\n        pure\n        returns (bytes32 beaconId);\n}\n"
    },
    "contracts/rrp/requesters/mock/MockRrpRequesterV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../RrpRequesterV0.sol\";\n\n/// @title A mock Airnode RRP requester contract\ncontract MockRrpRequesterV0 is RrpRequesterV0 {\n    event FulfilledRequest(bytes32 indexed requestId, bytes data);\n\n    mapping(bytes32 => bytes) public requestIdToData;\n\n    mapping(bytes32 => bool) private expectingRequestWithIdToBeFulfilled;\n\n    /// @param airnodeRrpAddress Airnode RRP contract address\n    constructor(address airnodeRrpAddress) RrpRequesterV0(airnodeRrpAddress) {}\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external {\n        bytes32 requestId = airnodeRrp.makeTemplateRequest(\n            templateId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external {\n        bytes32 requestId = airnodeRrp.makeFullRequest(\n            airnode,\n            endpointId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfill(bytes32 requestId, bytes calldata data)\n        external\n        onlyAirnodeRrp\n    {\n        require(\n            expectingRequestWithIdToBeFulfilled[requestId],\n            \"No such request made\"\n        );\n        delete expectingRequestWithIdToBeFulfilled[requestId];\n        requestIdToData[requestId] = data;\n        emit FulfilledRequest(requestId, data);\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysReverts(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        revert(\"Always reverts\");\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysRevertsWithNoString(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        revert(); // solhint-disable-line reason-string\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment running out of gas\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysRunsOutOfGas(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        while (true) {}\n    }\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @dev The withdrawal requested by calling this will revert because this\n    /// contract does not implement a default payable method\n    /// @param airnode Airnode address\n    /// @param sponsorWallet Sponsor wallet that the withdrawal is requested\n    /// from\n    function requestWithdrawal(address airnode, address sponsorWallet)\n        external\n    {\n        airnodeRrp.requestWithdrawal(airnode, sponsorWallet);\n    }\n}\n"
    },
    "contracts/authorizers/mock/MockAuthorizerAlwaysTrueV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/IAuthorizerV0.sol\";\n\n/// @title A mock authorizer that always returns true\ncontract MockAuthorizerAlwaysTrueV0 is IAuthorizerV0 {\n    function isAuthorizedV0(\n        bytes32 requestId, // solhint-disable-line\n        address airnode, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        address sponsor, // solhint-disable-line\n        address requester // solhint-disable-line\n    ) external view virtual override returns (bool status) {\n        status = true;\n    }\n}\n"
    },
    "contracts/authorizers/mock/MockAuthorizerAlwaysFalseV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/IAuthorizerV0.sol\";\n\n/// @title A mock authorizer that always returns false\ncontract MockAuthorizerAlwaysFalseV0 is IAuthorizerV0 {\n    function isAuthorizedV0(\n        bytes32 requestId, // solhint-disable-line\n        address airnode, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        address sponsor, // solhint-disable-line\n        address requester // solhint-disable-line\n    ) external view virtual override returns (bool status) {\n        status = false;\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IRequesterAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAuthorizerV0.sol\";\n\ninterface IRequesterAuthorizer is IAuthorizerV0 {\n    event ExtendedWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external;\n\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function isAuthorized(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/authorizers/RequesterAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../whitelist/Whitelist.sol\";\nimport \"./interfaces/IRequesterAuthorizer.sol\";\n\n/// @title Abstract contract to be inherited by Authorizer contracts that\n/// temporarily or permanently whitelist requesters for Airnode–endpoint pairs\nabstract contract RequesterAuthorizer is Whitelist, IRequesterAuthorizer {\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair and emits an event\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpirationAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        _extendWhitelistExpiration(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            expirationTimestamp\n        );\n        emit ExtendedWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair and emits an event\n    /// @dev Unlike `_extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpirationAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        _setWhitelistExpiration(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            expirationTimestamp\n        );\n        emit SetWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair and emits an event\n    /// @dev Emits the event even if it does not change the state.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatusAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to `requester`\n    /// for the `airnode`–`endpointId` pair by a specific account and emits an\n    /// event\n    /// @dev Only emits the event if it changes the state\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatusAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(setter != address(0), \"Setter address zero\");\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(\n                deriveServiceId(airnode, endpointId),\n                requester,\n                setter\n            );\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                airnode,\n                endpointId,\n                requester,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(deriveServiceId(airnode, endpointId), requester);\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because V0 authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorizedV0(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(deriveServiceId(airnode, endpointId), requester);\n    }\n\n    /// @notice Returns the whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @return expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    /// @return indefiniteWhitelistCount Number of times `requester` was\n    /// whitelisted indefinitely for the `airnode`–`endpointId` pair\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                deriveServiceId(airnode, endpointId)\n            ][requester];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted `requester`\n    /// for the `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// `requester` for the `airnode`–`endpointId` pair indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted `requester` for the `airnode`–`endpointId` pair\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            deriveServiceId(airnode, endpointId)\n        ][requester][setter];\n    }\n\n    /// @notice Called privately to derive a service ID out of the Airnode\n    /// address and the endpoint ID\n    /// @dev This is done to re-use the more general Whitelist contract for\n    /// the specific case of Airnode–endpoint pairs\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @return serviceId Service ID\n    function deriveServiceId(address airnode, bytes32 endpointId)\n        private\n        pure\n        returns (bytes32 serviceId)\n    {\n        serviceId = keccak256(abi.encodePacked(airnode, endpointId));\n    }\n}\n"
    },
    "contracts/authorizers/RequesterAuthorizerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../whitelist/WhitelistRolesWithManager.sol\";\nimport \"./RequesterAuthorizer.sol\";\nimport \"./interfaces/IRequesterAuthorizerWithManager.sol\";\n\n/// @title Authorizer contract that a manager can use to temporarily or\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\ncontract RequesterAuthorizerWithManager is\n    WhitelistRolesWithManager,\n    RequesterAuthorizer,\n    IRequesterAuthorizerWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\n    /// whitelist expiration extender role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsManager(msg.sender),\n            \"Cannot extend expiration\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\n    /// expiration setter role\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsManager(msg.sender),\n            \"Cannot set expiration\"\n        );\n        _setWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\n    /// whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsManager(msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            status\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsManager(setter),\n            \"setter can set indefinite status\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            setter\n        );\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IRequesterAuthorizerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../whitelist/interfaces/IWhitelistRolesWithManager.sol\";\nimport \"./IRequesterAuthorizer.sol\";\n\ninterface IRequesterAuthorizerWithManager is\n    IWhitelistRolesWithManager,\n    IRequesterAuthorizer\n{}\n"
    },
    "contracts/authorizers/RequesterAuthorizerWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../whitelist/WhitelistRolesWithAirnode.sol\";\nimport \"./RequesterAuthorizer.sol\";\nimport \"./interfaces/IRequesterAuthorizerWithAirnode.sol\";\n\n/// @title Authorizer contract that Airnode operators can use to temporarily or\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\ncontract RequesterAuthorizerWithAirnode is\n    WhitelistRolesWithAirnode,\n    RequesterAuthorizer,\n    IRequesterAuthorizerWithAirnode\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    )\n        WhitelistRolesWithAirnode(_accessControlRegistry, _adminRoleDescription)\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\n    /// whitelist expiration extender role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsAirnode(airnode, msg.sender),\n            \"Cannot extend expiration\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\n    /// expiration setter role\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsAirnode(airnode, msg.sender),\n            \"Cannot set expiration\"\n        );\n        _setWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\n    /// whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            status\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, setter),\n            \"setter can set indefinite status\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            setter\n        );\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IRequesterAuthorizerWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../whitelist/interfaces/IWhitelistRolesWithAirnode.sol\";\nimport \"./IRequesterAuthorizer.sol\";\n\ninterface IRequesterAuthorizerWithAirnode is\n    IWhitelistRolesWithAirnode,\n    IRequesterAuthorizer\n{}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
