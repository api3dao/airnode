import { ethers } from 'ethers';
import * as decoding from './decoding';

describe('decode', () => {
  it('decodes empty parameters', () => {
    // Encoding an empty array gets the below value
    const res = decoding.decode('0x3100000000000000000000000000000000000000000000000000000000000000');
    expect(res).toEqual({});
  });

  it('has a special case for 0x', () => {
    const res = decoding.decode('0x');
    expect(res).toEqual({});
  });

  it('decodes address types', () => {
    const data =
      '0x316100000000000000000000000000000000000000000000000000000000000054657374416464726573734e616d6500000000000000000000000000000000000000000000000000000000004128922394c63a204dd98ea6fbd887780b78bb7d';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestAddressName: '0x4128922394C63A204Dd98ea6fbd887780b78bb7d' });
  });

  it('decodes int256 types', () => {
    const data =
      '0x316900000000000000000000000000000000000000000000000000000000000054657374496e744e616d65000000000000000000000000000000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestIntName: '-1000' });
  });

  it('decodes uint256 types', () => {
    const data =
      '0x31750000000000000000000000000000000000000000000000000000000000005465737455496e744e616d65000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007d0';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestUIntName: '2000' });
  });

  it('decodes bytes types', () => {
    const data =
      '0x31420000000000000000000000000000000000000000000000000000000000005465737442797465734e616d650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000003123abc0000000000000000000000000000000000000000000000000000000000';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestBytesName: '0x123abc' });
  });

  it('decodes bytes32 types', () => {
    const data =
      '0x316200000000000000000000000000000000000000000000000000000000000054657374427974657333324e616d65000000000000000000000000000000000072616e646f6d737472696e670000000000000000000000000000000000000000';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestBytes32Name: '0x72616e646f6d737472696e670000000000000000000000000000000000000000' });
  });

  it('decodes string types', () => {
    const data =
      '0x315300000000000000000000000000000000000000000000000000000000000054657374537472696e674e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000011536f6d6520737472696e672076616c7565000000000000000000000000000000';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestStringName: 'Some string value' });
  });

  it('decodes string32 types', () => {
    const data =
      '0x317300000000000000000000000000000000000000000000000000000000000054657374537472696e6733324e616d6500000000000000000000000000000000536f6d6520737472696e6733322076616c756500000000000000000000000000';
    const res = decoding.decode(data);
    expect(res).toEqual({ TestString32Name: 'Some string32 value' });
  });

  it('decodes boolean value', () => {
    const trueData =
      '0x3166000000000000000000000000000000000000000000000000000000000000426f6f6c65616e4e616d650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001';
    const falseData =
      '0x3166000000000000000000000000000000000000000000000000000000000000426f6f6c65616e4e616d650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';

    expect(decoding.decode(trueData)).toEqual({ BooleanName: true });
    expect(decoding.decode(falseData)).toEqual({ BooleanName: false });
  });

  it('decodes multiple types', () => {
    const data =
      '0x3173615369427566000000000000000000000000000000000000000000000000737472696e673332206e616d6500000000000000000000000000000000000000737472696e6733322076616c756500000000000000000000000000000000000077616c6c657400000000000000000000000000000000000000000000000000000000000000000000000000004128922394c63a204dd98ea6fbd887780b78bb7d737472696e67206e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e062616c616e636500000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff7538dcfb761800006279746573206e616d65000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000220686f6c6465727300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001158e460913d00000626f6f6c56616c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000c737472696e672076616c756500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003123abc0000000000000000000000000000000000000000000000000000000000';
    const res = decoding.decode(data);
    expect(res).toEqual({
      'string32 name': 'string32 value',
      'bytes name': '0x123abc',
      'string name': 'string value',
      balance: '-10000000000000000000',
      holders: '20000000000000000000',
      wallet: '0x4128922394C63A204Dd98ea6fbd887780b78bb7d',
      boolVal: true,
    });
  });

  it('throws an error for AddressZero', () => {
    expect(() => decoding.decode(ethers.constants.AddressZero)).toThrow();
  });

  it('throws an error for HashZero', () => {
    expect(() => decoding.decode(ethers.constants.HashZero)).toThrow();
  });

  it('throws an error for empty strings', () => {
    expect(() => decoding.decode('')).toThrow();
  });

  it('throws an error when invalid data is provided', () => {
    expect(() => decoding.decode('0x123456')).toThrow();
  });

  it('shows the need to check for trailing bytes', () => {
    const encodedData = '0x0000000000000000000000000000000000000000000000000000000000000001';
    const encodedDataWithTrailingBytes = '0x000000000000000000000000000000000000000000000000000000000000000100';
    const decoded = ethers.utils.defaultAbiCoder.decode(['uint256'], encodedData);
    const decodedWithTrailingBytes = ethers.utils.defaultAbiCoder.decode(['uint256'], encodedDataWithTrailingBytes);
    const reEncodedData = ethers.utils.defaultAbiCoder.encode(['uint256'], [decoded.toString()]);
    const reEncodedDataFromTrailingBytesData = ethers.utils.defaultAbiCoder.encode(
      ['uint256'],
      [decodedWithTrailingBytes.toString()]
    );
    expect(decoded).toEqual(decodedWithTrailingBytes);
    expect(reEncodedData === encodedData).toBeTruthy();
    expect(reEncodedDataFromTrailingBytesData === encodedData).toBeTruthy();
    expect(reEncodedDataFromTrailingBytesData === encodedDataWithTrailingBytes).toBeFalsy();
  });

  it('throws an error when data has trailing bytes', () => {
    const data =
      '0x316900000000000000000000000000000000000000000000000000000000000054657374496e744e616d65000000000000000000000000000000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1800';
    expect(() => decoding.decode(data)).toThrow('Re-encoding mismatch');
  });
});
