{
  "language": "Solidity",
  "sources": {
    "contracts/AirnodeParameterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./RequesterStore.sol\";\nimport \"./interfaces/IAirnodeParameterStore.sol\";\nimport \"./authorizers/interfaces/IAuthorizer.sol\";\n\n/// @title The contract where the Airnode parameters are stored\ncontract AirnodeParameterStore is RequesterStore, IAirnodeParameterStore {\n    struct AirnodeParameter {\n        address admin;\n        string xpub;\n        address[] authorizers;\n        }\n\n    mapping(bytes32 => AirnodeParameter) internal airnodeParameters;\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\n\n    /// @notice Allows the master wallet (m) of the Airnode to set its\n    /// parameters on this chain\n    /// @dev This method can also be used to update `admin`, `xpub` and/or\n    /// `authorizers`.\n    /// `admin` is not used in the protocol contracts. It is intended to\n    /// potentially be referred to in authorizer contracts.\n    /// Note that the Airnode can announce an incorrect `xpub`. However, the\n    /// mismatch between it and the airnodeId can be detected off-chain.\n    /// This needs to be payable to be callable by\n    /// setAirnodeParametersAndForwardFunds().\n    /// @param admin Airnode admin\n    /// @param xpub Master public key of the Airnode\n    /// @param authorizers Authorizer contract addresses of the Airnode\n    /// @return airnodeId Airnode ID\n    function setAirnodeParameters(\n        address admin,\n        string calldata xpub,\n        address[] calldata authorizers\n        )\n        public\n        payable\n        override\n        returns (bytes32 airnodeId)\n    {\n        airnodeId = keccak256(abi.encode(msg.sender));\n        airnodeParameters[airnodeId] = AirnodeParameter({\n            admin: admin,\n            xpub: xpub,\n            authorizers: authorizers\n            });\n        emit AirnodeParametersSet(\n            airnodeId,\n            admin,\n            xpub,\n            authorizers\n            );\n    }\n\n    /// @notice Called by the requester admin to create a request for the\n    /// Airnode to send the funds kept in their designated wallet to the\n    /// destination\n    /// @dev We do not need to use the withdrawal request parameters in the\n    /// request ID hash to validate them at the node side because all of the\n    /// parameters are used during fulfillment and will get validated on-chain\n    /// @param airnodeId Airnode ID\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param designatedWallet Designated wallet that the withdrawal is\n    /// requested from\n    /// @param destination Withdrawal destination\n    function requestWithdrawal(\n        bytes32 airnodeId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address destination\n    )\n        external\n        override\n        onlyRequesterAdmin(requesterIndex)\n    {\n        bytes32 withdrawalRequestId = keccak256(abi.encodePacked(\n            requesterIndexToNextWithdrawalRequestIndex[requesterIndex]++,\n            block.chainid,\n            requesterIndex\n            ));\n        bytes32 withdrawalParameters = keccak256(abi.encodePacked(\n            airnodeId,\n            requesterIndex,\n            designatedWallet,\n            destination\n            ));\n        withdrawalRequestIdToParameters[withdrawalRequestId] = withdrawalParameters;\n        emit WithdrawalRequested(\n            airnodeId,\n            requesterIndex,\n            withdrawalRequestId,\n            designatedWallet,\n            destination\n            );\n    }\n\n    /// @notice Called by the Airnode using the designated wallet to\n    /// fulfill the withdrawal request made by the requester\n    /// @dev The Airnode sends the funds through this method to emit an\n    /// event that indicates that the withdrawal request has been fulfilled\n    /// @param airnodeId Airnode ID\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param destination Withdrawal destination\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        bytes32 airnodeId,\n        uint256 requesterIndex,\n        address destination\n        )\n        external\n        payable\n        override\n    {\n        bytes32 withdrawalParameters = keccak256(abi.encodePacked(\n            airnodeId,\n            requesterIndex,\n            msg.sender,\n            destination\n            ));\n        require(\n            withdrawalRequestIdToParameters[withdrawalRequestId] == withdrawalParameters,\n            \"No such withdrawal request\"\n            );\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\n        emit WithdrawalFulfilled(\n            airnodeId,\n            requesterIndex,\n            withdrawalRequestId,\n            msg.sender,\n            destination,\n            msg.value\n            );\n        (bool success, ) = destination.call{ value: msg.value }(\"\");  // solhint-disable-line\n        require(success, \"Transfer failed\");\n    }\n\n    /// @notice Uses the authorizer contracts of an Airnode to decide if a\n    /// request is authorized. Once an Airnode receives a request, it calls\n    /// this method to determine if it should respond. Similarly, third parties\n    /// can use this method to determine if a particular request would be\n    /// authorized.\n    /// @dev This method is meant to be called off-chain by the Airnode to\n    /// decide if it should respond to a request. The requester can also call\n    /// it, yet this function returning true should not be taken as a guarantee\n    /// of the subsequent call request being fulfilled (as the Airnode may\n    /// update its authorizers in the meantime).\n    /// The Airnode authorizers being empty means all requests will be denied,\n    /// while any `address(0)` authorizer means all requests will be accepted.\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param requestId Request ID\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param designatedWallet Designated wallet\n    /// @param clientAddress Client address\n    /// @return status Authorization status of the request\n    function checkAuthorizationStatus(\n        bytes32 airnodeId,\n        bytes32 requestId,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address clientAddress\n        )\n        public\n        view\n        override\n        returns (bool status)\n    {\n        address[] memory authorizerAddresses = airnodeParameters[airnodeId].authorizers;\n        uint256 noAuthorizers = authorizerAddresses.length;\n        for (uint256 ind = 0; ind < noAuthorizers; ind++)\n        {\n            address authorizerAddress = authorizerAddresses[ind];\n            if (authorizerAddress == address(0))\n            {\n                return true;\n            }\n            IAuthorizer authorizer = IAuthorizer(authorizerAddress);\n            if (authorizer.isAuthorized(\n                requestId,\n                airnodeId,\n                endpointId,\n                requesterIndex,\n                designatedWallet,\n                clientAddress\n                ))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Retrieves the parameters of the Airnode addressed by the ID\n    /// @param airnodeId Airnode ID\n    /// @return admin Airnode admin\n    /// @return xpub Master public key of the Airnode\n    /// @return authorizers Authorizer contract addresses of the Airnode\n    function getAirnodeParameters(bytes32 airnodeId)\n        external\n        view\n        override\n        returns (\n            address admin,\n            string memory xpub,\n            address[] memory authorizers\n        )\n    {\n        AirnodeParameter storage airnodeParameter = airnodeParameters[airnodeId];\n        admin = airnodeParameter.admin;\n        xpub = airnodeParameter.xpub;\n        authorizers = airnodeParameter.authorizers;\n    }\n}\n"
    },
    "contracts/RequesterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./interfaces/IRequesterStore.sol\";\n\n/// @title The contract where the requesters are stored\n/// @notice This contract is used by requesters to manage their endorsemenets.\n/// A requester endorsing a client means that the client can request their\n/// requests to be fulfilled by the respective requester's designated wallets.\ncontract RequesterStore is IRequesterStore {\n    mapping(uint256 => address) public requesterIndexToAdmin;\n    mapping(uint256 => mapping(address => bool)) public requesterIndexToClientAddressToEndorsementStatus;\n    mapping(address => uint256) public clientAddressToNoRequests;\n    mapping(uint256 => uint256) public requesterIndexToNextWithdrawalRequestIndex;\n    uint256 private noRequesters = 1;\n\n    /// @dev Reverts if the caller is not the requester admin\n    /// @param requesterIndex Requester index\n    modifier onlyRequesterAdmin(uint256 requesterIndex)\n    {\n        require(\n            msg.sender == requesterIndexToAdmin[requesterIndex],\n            \"Caller not requester admin\"\n            );\n        _;\n    }\n\n    /// @notice Creates a requester with the given parameters, addressable by\n    /// the index it returns\n    /// @param admin Requester admin\n    /// @return requesterIndex Requester index\n    function createRequester(address admin)\n        external\n        override\n        returns (uint256 requesterIndex)\n    {\n        requesterIndex = noRequesters++;\n        requesterIndexToAdmin[requesterIndex] = admin;\n        // Initialize the requester nonce during creation for consistent\n        // withdrawal request gas cost\n        requesterIndexToNextWithdrawalRequestIndex[requesterIndex] = 1;\n        emit RequesterCreated(\n            requesterIndex,\n            admin\n            );\n    }\n\n    /// @notice Sets the requester admin\n    /// @param requesterIndex Requester index\n    /// @param admin Requester admin\n    function setRequesterAdmin(\n        uint256 requesterIndex,\n        address admin\n        )\n        external\n        override\n        onlyRequesterAdmin(requesterIndex)\n    {\n        requesterIndexToAdmin[requesterIndex] = admin;\n        emit RequesterUpdated(\n            requesterIndex,\n            admin\n            );\n    }\n\n    /// @notice Called by the requester admin to endorse a client, i.e., allow\n    /// a client to use its designated wallets, or disendorse them\n    /// @dev This is not Airnode-specific, i.e., the requester allows the\n    /// client's requests to be fulfilled through its designated wallets across\n    /// all Airnodes\n    /// @param requesterIndex Requester index\n    /// @param clientAddress Client address\n    function setClientEndorsementStatus(\n        uint256 requesterIndex,\n        address clientAddress,\n        bool endorsementStatus\n        )\n        external\n        override\n        onlyRequesterAdmin(requesterIndex)\n    {\n        // Initialize the client nonce for consistent request gas cost\n        if (clientAddressToNoRequests[clientAddress] == 0)\n        {\n            clientAddressToNoRequests[clientAddress] = 1;\n        }\n        requesterIndexToClientAddressToEndorsementStatus[requesterIndex][clientAddress] = endorsementStatus;\n        emit ClientEndorsementStatusSet(\n            requesterIndex,\n            clientAddress,\n            endorsementStatus\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IAirnodeParameterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IRequesterStore.sol\";\n\ninterface IAirnodeParameterStore is IRequesterStore {\n    event AirnodeParametersSet(\n        bytes32 indexed airnodeId,\n        address admin,\n        string xpub,\n        address[] authorizers\n        );\n\n    event WithdrawalRequested(\n        bytes32 indexed airnodeId,\n        uint256 indexed requesterIndex,\n        bytes32 indexed withdrawalRequestId,\n        address designatedWallet,\n        address destination\n        );\n\n    event WithdrawalFulfilled(\n        bytes32 indexed airnodeId,\n        uint256 indexed requesterIndex,\n        bytes32 indexed withdrawalRequestId,\n        address designatedWallet,\n        address destination,\n        uint256 amount\n        );\n\n    function setAirnodeParameters(\n        address admin,\n        string calldata xpub,\n        address[] calldata authorizers\n        )\n        external\n        payable\n        returns (bytes32 airnodeId);\n\n    function requestWithdrawal(\n        bytes32 airnodeId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address destination\n    )\n        external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        bytes32 airnodeId,\n        uint256 requesterIndex,\n        address destination\n        )\n        external\n        payable;\n\n    function checkAuthorizationStatus(\n        bytes32 airnodeId,\n        bytes32 requestId,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address clientAddress\n        )\n        external\n        view\n        returns (bool status);\n\n    function getAirnodeParameters(bytes32 airnodeId)\n        external\n        view\n        returns (\n            address admin,\n            string memory xpub,\n            address[] memory authorizers\n        );\n}\n"
    },
    "contracts/authorizers/interfaces/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IAuthorizer {\n    function authorizerType()\n        external\n        view\n        returns (uint256);\n\n    function isAuthorized(\n        bytes32 requestId,\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address clientAddress\n        )\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/interfaces/IRequesterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IRequesterStore {\n    event RequesterCreated(\n        uint256 indexed requesterIndex,\n        address admin\n        );\n\n    event RequesterUpdated(\n        uint256 indexed requesterIndex,\n        address admin\n        );\n\n    event ClientEndorsementStatusSet(\n        uint256 indexed requesterIndex,\n        address indexed clientAddress,\n        bool endorsementStatus\n        );\n\n    function createRequester(address admin)\n        external\n        returns (uint256 requesterIndex);\n\n    function setRequesterAdmin(\n        uint256 requesterIndex,\n        address admin\n        )\n        external;\n\n    function setClientEndorsementStatus(\n        uint256 requesterIndex,\n        address clientAddress,\n        bool endorsementStatus\n        )\n        external;\n}\n"
    },
    "contracts/Convenience.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./AirnodeParameterStore.sol\";\nimport \"./TemplateStore.sol\";\nimport \"./interfaces/IConvenience.sol\";\n\n/// @title The contract that keeps the convenience methods that Airnodes use to\n/// make batch calls\ncontract Convenience is AirnodeParameterStore, TemplateStore, IConvenience {\n    /// @notice A convenience method for the Airnode to set its parameters\n    /// and forward the remaining funds in the master wallet to the Airnode\n    /// admin\n    /// @param admin Airnode admin\n    /// @param xpub Master public key of the Airnode\n    /// @param authorizers Authorizer contract addresses of the Airnode\n    /// @return airnodeId Airnode ID from AirnodeParameterStore\n    function setAirnodeParametersAndForwardFunds(\n        address admin,\n        string calldata xpub,\n        address[] calldata authorizers\n        )\n        external\n        payable\n        override\n        returns (bytes32 airnodeId)\n    {\n        airnodeId = setAirnodeParameters(\n            admin,\n            xpub,\n            authorizers\n            );\n        if (msg.value > 0)\n        {\n            (bool success, ) = admin.call{ value: msg.value }(\"\");  // solhint-disable-line\n            require(success, \"Transfer failed\");\n        }\n    }\n\n    /// @notice A convenience method to retrieve the Airnode parameters and\n    /// the block number with a single call\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @return admin Airnode admin\n    /// @return xpub Master public key of the Airnode\n    /// @return authorizers Authorizer contract addresses of the Airnode\n    /// @return blockNumber Block number\n    function getAirnodeParametersAndBlockNumber(bytes32 airnodeId)\n        external\n        view\n        override\n        returns (\n            address admin,\n            string memory xpub,\n            address[] memory authorizers,\n            uint256 blockNumber\n        )\n    {\n        AirnodeParameter storage airnodeParameter = airnodeParameters[airnodeId];\n        admin = airnodeParameter.admin;\n        xpub = airnodeParameter.xpub;\n        authorizers = airnodeParameter.authorizers;\n        blockNumber = block.number;\n    }\n\n    /// @notice A convenience method to retrieve multiple templates with a\n    /// single call\n    /// @dev If this reverts, Airnode will use getTemplate() to get the\n    /// templates individually\n    /// @param templateIds Request template IDs from TemplateStore\n    /// @return airnodeIds Array of Airnode IDs from AirnodeParameterStore\n    /// @return endpointIds Array of endpoint IDs from EndpointStore\n    /// @return parameters Array of request parameters\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        override\n        returns (\n            bytes32[] memory airnodeIds,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        )\n    {\n        airnodeIds = new bytes32[](templateIds.length);\n        endpointIds = new bytes32[](templateIds.length);\n        parameters = new bytes[](templateIds.length);\n        for (uint256 ind = 0; ind < templateIds.length; ind++)\n        {\n            Template storage template = templates[templateIds[ind]];\n            airnodeIds[ind] = template.airnodeId;\n            endpointIds[ind] = template.endpointId;\n            parameters[ind] = template.parameters;\n        }\n    }\n\n    /// @notice A convenience function to make multiple authorization status\n    /// checks with a single call\n    /// @dev If this reverts, Airnode will use checkAuthorizationStatus() to\n    /// do the checks individually\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param requestIds Request IDs\n    /// @param endpointIds Endpoint IDs from EndpointStore\n    /// @param requesterIndices Requester indices from RequesterStore\n    /// @param designatedWallets Designated wallets\n    /// @param clientAddresses Client addresses\n    /// @return statuses Authorization statuses of the request\n    function checkAuthorizationStatuses(\n        bytes32 airnodeId,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        uint256[] calldata requesterIndices,\n        address[] calldata designatedWallets,\n        address[] calldata clientAddresses\n        )\n        external\n        view\n        override\n        returns (bool[] memory statuses)\n    {\n        require(\n            requestIds.length == endpointIds.length\n                && requestIds.length == requesterIndices.length\n                && requestIds.length == designatedWallets.length\n                && requestIds.length == clientAddresses.length,\n            \"Unequal parameter lengths\"\n        );\n        statuses = new bool[](requestIds.length);\n        for (uint256 ind = 0; ind < requestIds.length; ind++)\n        {\n            statuses[ind] = checkAuthorizationStatus(\n                airnodeId,\n                requestIds[ind],\n                endpointIds[ind],\n                requesterIndices[ind],\n                designatedWallets[ind],\n                clientAddresses[ind]\n                );\n        }\n    }\n}\n"
    },
    "contracts/TemplateStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./interfaces/ITemplateStore.sol\";\n\n/// @title The contract where the request templates are stored\n/// @notice Most requests are repeated many times with the same parameters.\n/// This contract allows the requester to announce their parameters once, then\n/// refer to that announcement to make a request instead of passing the same\n/// parameters repeatedly.\ncontract TemplateStore is ITemplateStore {\n    struct Template {\n        bytes32 airnodeId;\n        bytes32 endpointId;\n        bytes parameters;\n        }\n\n    mapping(bytes32 => Template) internal templates;\n\n    /// @notice Creates a request template with the given parameters,\n    /// addressable by the ID it returns\n    /// @dev A specific set of request parameters will always have\n    /// the same ID. This means a few things: (1) You can compute the expected\n    /// ID of a set of parameters off-chain, (2) creating a new template with\n    /// the same parameters will overwrite the old one and return the same\n    /// template ID, (3) after you query a template with its ID, you can verify\n    /// its integrity by applying the hash and comparing the result with the\n    /// ID.\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at request-time)\n    /// @return templateId Request template ID\n    function createTemplate(\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        templateId = keccak256(abi.encode(\n            airnodeId,\n            endpointId,\n            parameters\n            ));\n        templates[templateId] = Template({\n            airnodeId: airnodeId,\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit TemplateCreated(\n          templateId,\n          airnodeId,\n          endpointId,\n          parameters\n          );\n    }\n\n    /// @notice Retrieves the parameters of the request template addressed by\n    /// the ID\n    /// @param templateId Request template ID\n    /// @return airnodeId Airnode ID from AirnodeParameterStore\n    /// @return endpointId Endpoint ID from EndpointStore\n    /// @return parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at request-time)\n    function getTemplate(bytes32 templateId)\n        external\n        view\n        override\n        returns (\n            bytes32 airnodeId,\n            bytes32 endpointId,\n            bytes memory parameters\n        )\n    {\n        Template storage template = templates[templateId];\n        airnodeId = template.airnodeId;\n        endpointId = template.endpointId;\n        parameters = template.parameters;\n    }\n}\n"
    },
    "contracts/interfaces/IConvenience.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./IAirnodeRrp.sol\";\n\ninterface IConvenience {\n    function setAirnodeParametersAndForwardFunds(\n        address admin,\n        string calldata xpub,\n        address[] calldata authorizers\n        )\n        external\n        payable\n        returns (bytes32 airnodeId);\n\n    function getAirnodeParametersAndBlockNumber(bytes32 airnodeId)\n        external\n        view\n        returns (\n            address admin,\n            string memory xpub,\n            address[] memory authorizers,\n            uint256 blockNumber\n        );\n\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        returns (\n            bytes32[] memory airnodeIds,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        );\n\n    function checkAuthorizationStatuses(\n        bytes32 airnodeId,\n        bytes32[] calldata requestIds, \n        bytes32[] calldata endpointIds,\n        uint256[] calldata requesterIndices,\n        address[] calldata designatedWallets,\n        address[] calldata clientAddresses\n        )\n        external\n        view\n        returns (bool[] memory statuses);\n}\n"
    },
    "contracts/interfaces/ITemplateStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface ITemplateStore {\n    event TemplateCreated(\n        bytes32 indexed templateId,\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        bytes parameters\n        );\n\n    function createTemplate(\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 templateId);\n\n    function getTemplate(bytes32 templateId)\n        external\n        view\n        returns (\n            bytes32 airnodeId,\n            bytes32 endpointId,\n            bytes memory parameters\n        );\n}\n"
    },
    "contracts/interfaces/IAirnodeRrp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IAirnodeParameterStore.sol\";\nimport \"./ITemplateStore.sol\";\n\ninterface IAirnodeRrp is IAirnodeParameterStore, ITemplateStore {\n    event ClientRequestCreated(\n        bytes32 indexed airnodeId,\n        bytes32 indexed requestId,\n        uint256 noRequests,\n        uint256 chainId,\n        address clientAddress,\n        bytes32 templateId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n        );\n\n    event ClientFullRequestCreated(\n        bytes32 indexed airnodeId,\n        bytes32 indexed requestId,\n        uint256 noRequests,\n        uint256 chainId,\n        address clientAddress,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n        );\n\n    event ClientRequestFulfilled(\n        bytes32 indexed airnodeId,\n        bytes32 indexed requestId,\n        uint256 statusCode,\n        bytes data\n        );\n\n    event ClientRequestFailed(\n        bytes32 indexed airnodeId,\n        bytes32 indexed requestId\n        );\n\n    function makeRequest(\n        bytes32 templateId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 requestId);\n\n    function makeFullRequest(\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 requestId);\n\n    function fulfill(\n        bytes32 requestId,\n        bytes32 airnodeId,\n        uint256 statusCode,\n        bytes calldata data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        returns (\n            bool callSuccess,\n            bytes memory callData\n        );\n\n    function fail(\n        bytes32 requestId,\n        bytes32 airnodeId,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external;\n}\n"
    },
    "contracts/authorizers/SelfAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../interfaces/IAirnodeRrp.sol\";\nimport \"./interfaces/ISelfAuthorizer.sol\";\n\n/// @title Authorizer contract where each Airnode is their own admin\ncontract SelfAuthorizer is ISelfAuthorizer {\n    string private constant ERROR_UNAUTHORIZED                = \"Unauthorized\";\n    string private constant ERROR_ZERO_ADDRESS                = \"Zero address\";\n    string private constant ERROR_EXPIRATION_NOT_EXTENDED     = \"Expiration not extended\";\n\n    /// @dev Authorizer contracts can use `authorizerType` to signal their type\n    uint256 public override immutable authorizerType = 2;\n    IAirnodeRrp public airnodeRrp;\n    mapping(bytes32 => mapping(address => AdminStatus)) public\n        airnodeIdToAdminStatuses;\n    mapping(bytes32 => mapping(address => uint256)) public\n        airnodeIdToClientAddressToWhitelistExpiration;\n    mapping(bytes32 => mapping(address => bool)) public\n        airnodeIdToClientAddressToBlacklistStatus;\n\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor (address _airnodeRrp)\n    {\n        require(\n            _airnodeRrp != address(0),\n            ERROR_ZERO_ADDRESS\n            );\n        airnodeRrp = IAirnodeRrp(_airnodeRrp);\n    }\n\n    /// @notice Called by the Airnode admin to set the admin status of an\n    /// address\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param admin Address whose admin status will be set\n    /// @param status Admin status\n    function setAdminStatus(\n        bytes32 airnodeId,\n        address admin,\n        AdminStatus status\n        )\n        external\n        override\n    {\n        (address airnodeAdmin, , ) = airnodeRrp.getAirnodeParameters(airnodeId);\n        require(\n            msg.sender == airnodeAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        airnodeIdToAdminStatuses[airnodeId][admin] = status;\n        emit SetAdminStatus(\n            airnodeId,\n            admin,\n            status\n            );\n    }\n\n    /// @notice Called by an admin to renounce their admin status\n    /// @dev To minimize the number of transactions the Airnode admin will have\n    /// to make, the contract is implemented optimistically, i.e., the admins\n    /// are expected to renounce their admin status when they are needed to.\n    /// If this is not the case, the Airnode admin can always revoke their\n    /// adminship.\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    function renounceAdminStatus(bytes32 airnodeId)\n        external\n        override\n    {\n        require(\n            airnodeIdToAdminStatuses[airnodeId][msg.sender] > AdminStatus.Unauthorized,\n            ERROR_UNAUTHORIZED\n            );\n        airnodeIdToAdminStatuses[airnodeId][msg.sender] = AdminStatus.Unauthorized;\n        emit RenouncedAdminStatus(\n            airnodeId,\n            msg.sender\n            );\n    }\n\n    /// @notice Called by an admin to extend the whitelist expiration of a\n    /// client\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param clientAddress Client address\n    /// @param expiration Timestamp at which the client will no longer be\n    /// whitelisted\n    function extendWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external\n        override\n    {\n        (address airnodeAdmin, , ) = airnodeRrp.getAirnodeParameters(airnodeId);\n        require(\n            airnodeIdToAdminStatuses[airnodeId][msg.sender] >= AdminStatus.Admin || msg.sender == airnodeAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        require(\n            expiration > airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress],\n            ERROR_EXPIRATION_NOT_EXTENDED\n            );\n        airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress] = expiration;\n        emit ExtendedWhitelistExpiration(\n            airnodeId,\n            clientAddress,\n            expiration,\n            msg.sender\n            );\n    }\n\n    /// @notice Called by a super admin to extend the whitelisting of a client\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param clientAddress Client address\n    /// @param expiration Timestamp at which the whitelisting of the client\n    /// will expire\n    function setWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external\n        override\n    {\n        (address airnodeAdmin, , ) = airnodeRrp.getAirnodeParameters(airnodeId);\n        require(\n            airnodeIdToAdminStatuses[airnodeId][msg.sender] == AdminStatus.SuperAdmin || msg.sender == airnodeAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress] = expiration;\n        emit SetWhitelistExpiration(\n            airnodeId,\n            clientAddress,\n            expiration,\n            msg.sender\n            );\n    }\n\n    /// @notice Called by a super admin to set the blacklist status of a client\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param clientAddress Client address\n    /// @param status Blacklist status to be set\n    function setBlacklistStatus(\n        bytes32 airnodeId,\n        address clientAddress,\n        bool status\n        )\n        external\n        override\n    {\n        (address airnodeAdmin, , ) = airnodeRrp.getAirnodeParameters(airnodeId);\n        require(\n            airnodeIdToAdminStatuses[airnodeId][msg.sender] == AdminStatus.SuperAdmin || msg.sender == airnodeAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        airnodeIdToClientAddressToBlacklistStatus[airnodeId][clientAddress] = status;\n        emit SetBlacklistStatus(\n            airnodeId,\n            clientAddress,\n            status,\n            msg.sender\n            );\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here.\n    /// Note that we are also validating that the `designatedWallet` balance is\n    /// not `0`. The ideal condition to check would be if `designatedWallet`\n    /// has enough funds to fulfill the request. However, that is not a\n    /// condition that can be checked deterministically.\n    /// @param requestId Request ID\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param endpointId Endpoint ID\n    /// @param requesterIndex Requester index from `RequesterStore.sol`\n    /// @param designatedWallet Designated wallet\n    /// @param clientAddress Client address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId,        // solhint-disable-line\n        bytes32 airnodeId,\n        bytes32 endpointId,       // solhint-disable-line\n        uint256 requesterIndex,   // solhint-disable-line\n        address designatedWallet,\n        address clientAddress\n        )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return designatedWallet.balance != 0\n            && !airnodeIdToClientAddressToBlacklistStatus[airnodeId][clientAddress]\n            && airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress] > block.timestamp;\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/ISelfAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IAuthorizer.sol\";\n\ninterface ISelfAuthorizer is IAuthorizer {\n    // Unauthorized (0):  Cannot do anything\n    // Admin (1):         Can extend whitelistings\n    // Super admin (2):   Can set (i.e., extend or revoke) whitelistings, blacklist\n    enum AdminStatus {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n        }\n\n    event SetAdminStatus(\n        bytes32 indexed airnodeId,\n        address indexed admin,\n        AdminStatus status\n        );\n\n    event RenouncedAdminStatus(\n        bytes32 indexed airnodeId,\n        address indexed admin\n        );\n\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed airnodeId,\n        address indexed clientAddress,\n        uint256 expiration,\n        address indexed admin\n        );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed airnodeId,\n        address indexed clientAddress,\n        uint256 expiration,\n        address indexed admin\n        );\n\n    event SetBlacklistStatus(\n        bytes32 indexed airnodeId,\n        address indexed clientAddress,\n        bool status,\n        address indexed admin\n        );\n\n    function setAdminStatus(\n        bytes32 airnodeId,\n        address admin,\n        AdminStatus status\n        )\n        external;\n\n    function renounceAdminStatus(bytes32 airnodeId)\n        external;\n\n    function extendWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external;\n\n    function setWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external;\n\n    function setBlacklistStatus(\n        bytes32 airnodeId,\n        address clientAddress,\n        bool status\n        )\n        external;\n}\n"
    },
    "contracts/authorizers/mock/MockAuthorizerAlwaysTrue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../interfaces/IAuthorizer.sol\";\n\n/// @title A mock authorizer that always returns true\ncontract MockAuthorizerAlwaysTrue is IAuthorizer {\n    uint256 public override immutable authorizerType = 33;\n\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line\n        bytes32 airnodeId, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        uint256 requesterIndex, // solhint-disable-line\n        address designatedWallet, // solhint-disable-line\n        address clientAddress // solhint-disable-line\n        )\n        virtual\n        external\n        view\n        override\n        returns (bool status)\n    {\n        status = true;\n    }\n}\n"
    },
    "contracts/authorizers/mock/MockAuthorizerAlwaysFalse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../interfaces/IAuthorizer.sol\";\n\n/// @title A mock authorizer that always returns false\ncontract MockAuthorizerAlwaysFalse is IAuthorizer {\n    uint256 public override immutable authorizerType = 33;\n\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line\n        bytes32 airnodeId, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        uint256 requesterIndex, // solhint-disable-line\n        address designatedWallet, // solhint-disable-line\n        address clientAddress // solhint-disable-line\n        )\n        virtual\n        external\n        view\n        override\n        returns (bool status)\n    {\n        status = false;\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IApi3Authorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IAuthorizer.sol\";\n\ninterface IApi3Authorizer is IAuthorizer {\n    // Unauthorized (0):  Cannot do anything\n    // Admin (1):         Can extend whitelistings\n    // Super admin (2):   Can set (i.e., extend or revoke) whitelistings, blacklist\n    enum AdminStatus {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n        }\n\n    event SetMetaAdmin(address metaAdmin);\n\n    event SetAdminStatus(\n        address indexed admin,\n        AdminStatus status\n        );\n\n    event RenouncedAdminStatus(address indexed admin);\n\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed airnodeId,\n        address indexed clientAddress,\n        uint256 expiration,\n        address indexed admin\n        );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed airnodeId,\n        address indexed clientAddress,\n        uint256 expiration,\n        address indexed admin\n        );\n\n    event SetBlacklistStatus(\n        address indexed clientAddress,\n        bool status,\n        address indexed admin\n        );\n\n    function setMetaAdmin(address _metaAdmin)\n        external;\n\n    function setAdminStatus(\n        address admin,\n        AdminStatus status\n        )\n        external;\n\n    function renounceAdminStatus()\n        external;\n\n    function extendWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external;\n\n    function setWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external;\n  \n    function setBlacklistStatus(\n        address clientAddress,\n        bool status\n        )\n        external;\n}\n"
    },
    "contracts/authorizers/Api3Authorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./interfaces/IApi3Authorizer.sol\";\n\n/// @title Authorizer contract controlled by the API3 DAO\ncontract Api3Authorizer is IApi3Authorizer {\n    string private constant ERROR_UNAUTHORIZED                = \"Unauthorized\";\n    string private constant ERROR_ZERO_ADDRESS                = \"Zero address\";\n    string private constant ERROR_EXPIRATION_NOT_EXTENDED     = \"Expiration not extended\";\n\n    /// @dev Authorizer contracts can use `authorizerType` to signal their type\n    uint256 public override immutable authorizerType = 1;\n    /// @dev Meta admin sets the admin statuses of addresses and has super\n    /// admin privileges\n    address public metaAdmin;\n    mapping(address => AdminStatus) public adminStatuses;\n    mapping(bytes32 => mapping(address => uint256)) public\n        airnodeIdToClientAddressToWhitelistExpiration;\n    mapping(address => bool) public clientAddressToBlacklistStatus;\n\n    /// @param _metaAdmin Address that will be set as the meta admin\n    constructor (address _metaAdmin)\n    {\n        require(\n            _metaAdmin != address(0),\n            ERROR_ZERO_ADDRESS\n            );\n        metaAdmin = _metaAdmin;\n    }\n\n    /// @notice Called by the meta admin to set the meta admin\n    /// @param _metaAdmin Address that will be set as the meta admin\n    function setMetaAdmin(address _metaAdmin)\n        external\n        override\n    {\n        require(\n            msg.sender == metaAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        require(\n            _metaAdmin != address(0),\n            ERROR_ZERO_ADDRESS\n            );\n        metaAdmin = _metaAdmin;\n        emit SetMetaAdmin(metaAdmin);\n    }\n\n    /// @notice Called by the meta admin to set the admin status of an address\n    /// @param admin Address whose admin status will be set\n    /// @param status Admin status\n    function setAdminStatus(\n        address admin,\n        AdminStatus status\n        )\n        external\n        override\n    {\n        require(\n            msg.sender == metaAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        adminStatuses[admin] = status;\n        emit SetAdminStatus(\n            admin,\n            status\n            );\n    }\n\n    /// @notice Called by an admin to renounce their admin status\n    /// @dev To minimize the number of transactions the meta admin will have\n    /// to make, the contract is implemented optimistically, i.e., the admins\n    /// are expected to renounce their admin status when they are needed to.\n    /// If this is not the case, the meta admin can always revoke their\n    /// adminship.\n    /// This method cannot be used by the meta admin to renounce their meta\n    /// adminship.\n    function renounceAdminStatus()\n        external\n        override\n    {\n        require(\n            adminStatuses[msg.sender] > AdminStatus.Unauthorized,\n            ERROR_UNAUTHORIZED\n            );\n        adminStatuses[msg.sender] = AdminStatus.Unauthorized;\n        emit RenouncedAdminStatus(msg.sender);\n    }\n\n    /// @notice Called by an admin to extend the whitelist expiration of a\n    /// client\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param clientAddress Client address\n    /// @param expiration Timestamp at which the client will no longer be\n    /// whitelisted\n    function extendWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external\n        override\n    {\n        require(\n            adminStatuses[msg.sender] >= AdminStatus.Admin || msg.sender == metaAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        require(\n            expiration > airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress],\n            ERROR_EXPIRATION_NOT_EXTENDED\n            );\n        airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress] = expiration;\n        emit ExtendedWhitelistExpiration(\n            airnodeId,\n            clientAddress,\n            expiration,\n            msg.sender\n            );\n    }\n\n    /// @notice Called by a super admin to extend the whitelisting of a client\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param clientAddress Client address\n    /// @param expiration Timestamp at which the whitelisting of the client\n    /// will expire\n    function setWhitelistExpiration(\n        bytes32 airnodeId,\n        address clientAddress,\n        uint256 expiration\n        )\n        external\n        override\n    {\n        require(\n            adminStatuses[msg.sender] == AdminStatus.SuperAdmin || msg.sender == metaAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress] = expiration;\n        emit SetWhitelistExpiration(\n            airnodeId,\n            clientAddress,\n            expiration,\n            msg.sender\n            );\n    }\n\n    /// @notice Called by a super admin to set the blacklist status of a client\n    /// @param clientAddress Client address\n    /// @param status Blacklist status to be set\n    function setBlacklistStatus(\n        address clientAddress,\n        bool status\n        )\n        external\n        override\n    {\n        require(\n            adminStatuses[msg.sender] == AdminStatus.SuperAdmin || msg.sender == metaAdmin,\n            ERROR_UNAUTHORIZED\n            );\n        clientAddressToBlacklistStatus[clientAddress] = status;\n        emit SetBlacklistStatus(\n            clientAddress,\n            status,\n            msg.sender\n            );\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here.\n    /// Note that we are also validating that the `designatedWallet` balance is\n    /// not `0`. The ideal condition to check would be if `designatedWallet`\n    /// has enough funds to fulfill the request. However, that is not a\n    /// condition that can be checked deterministically.\n    /// @param requestId Request ID\n    /// @param airnodeId Airnode ID from `AirnodeParameterStore.sol`\n    /// @param endpointId Endpoint ID\n    /// @param requesterIndex Requester index from `RequesterStore.sol`\n    /// @param designatedWallet Designated wallet\n    /// @param clientAddress Client address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId,        // solhint-disable-line\n        bytes32 airnodeId,\n        bytes32 endpointId,       // solhint-disable-line\n        uint256 requesterIndex,   // solhint-disable-line\n        address designatedWallet,\n        address clientAddress\n        )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return designatedWallet.balance != 0\n            && !clientAddressToBlacklistStatus[clientAddress]\n            && airnodeIdToClientAddressToWhitelistExpiration[airnodeId][clientAddress] > block.timestamp;\n    }\n}\n"
    },
    "contracts/AirnodeRrpClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./interfaces/IAirnodeRrp.sol\";\n\n/// @title The contract to be inherited from to use Airnode to make requests\ncontract AirnodeRrpClient {\n    IAirnodeRrp public airnodeRrp;\n\n    /// @dev Reverts if the caller is not the Airnode RRP contract\n    /// Use it as a modifier for fulfill and error callback methods\n    modifier onlyAirnodeRrp()\n    {\n        require(\n            msg.sender == address(airnodeRrp),\n            \"Caller not Airnode RRP\"\n            );\n        _;\n    }\n\n    /// @dev Airnode RRP address is set at deployment. If you need to be able\n    /// to update it, you will have to implement that functionality (and\n    /// probably put it behind onlyOwner).\n    /// @param airnodeRrpAddress Airnode RRP contract address\n    constructor (address airnodeRrpAddress)\n    {\n        airnodeRrp = IAirnodeRrp(airnodeRrpAddress);\n    }\n}\n"
    },
    "contracts/mock/MockAirnodeRrpClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../AirnodeRrpClient.sol\";\n\n/// @title A mock Airnode RRP client contract\ncontract MockAirnodeRrpClient is AirnodeRrpClient {\n    event RequestFulfilled(\n        bytes32 requestId,\n        uint256 statusCode,\n        bytes data\n        );\n\n    mapping(bytes32 => bool) private incomingFulfillments;\n\n    /// @param airnodeRrpAddress Airnode RRP contract address\n    constructor (address airnodeRrpAddress)\n        AirnodeRrpClient(airnodeRrpAddress)\n    {}  // solhint-disable-line\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param templateId Template ID from TemplateStore\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param designatedWallet Designated wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\n    /// determined at runtime, unlike the static parameters stored in the\n    /// template)\n    function makeRequest(\n        bytes32 templateId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n        )\n        external\n    {\n        bytes32 requestId = airnodeRrp.makeRequest(\n            templateId,\n            requesterIndex,\n            designatedWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n            );\n        incomingFulfillments[requestId] = true;\n    }\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param designatedWallet Designated wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    function makeFullRequest(\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n        )\n        external\n    {\n        bytes32 requestId = airnodeRrp.makeFullRequest(\n            airnodeId,\n            endpointId,\n            requesterIndex,\n            designatedWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n            );\n        incomingFulfillments[requestId] = true;\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing\n    /// @param requestId Request ID\n    /// @param statusCode Status code returned by the Airnode\n    /// @param data Data returned by the Airnode\n    function fulfill(\n        bytes32 requestId,\n        uint256 statusCode,\n        bytes calldata data\n        )\n        external\n        onlyAirnodeRrp()\n    {\n        require(incomingFulfillments[requestId], \"No such request made\");\n        delete incomingFulfillments[requestId];\n        emit RequestFulfilled(\n            requestId,\n            statusCode,\n            data\n            );\n    }\n}\n"
    },
    "contracts/AirnodeRrp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./Convenience.sol\";\nimport \"./interfaces/IAirnodeRrp.sol\";\n\n/// @title The contract used to make and fulfill requests\n/// @notice Clients use this contract to make requests and Airnodes use it to\n/// fulfill them. In addition, it inherits from the contracts that keep records\n/// or Airnodes, requesters and templates. It also includes some convenience\n/// methods that Airnodes use to reduce the number of calls they make to\n/// blockchain providers.\ncontract AirnodeRrp is Convenience, IAirnodeRrp {\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\n    mapping(bytes32 => bool) public requestWithIdHasFailed;\n\n    /// @dev Reverts if the incoming fulfillment parameters do not match the\n    /// ones provided in the request\n    /// @param requestId Request ID\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    modifier onlyCorrectFulfillmentParameters(\n        bytes32 requestId,\n        bytes32 airnodeId,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n    {\n        bytes32 incomingFulfillmentParameters = keccak256(abi.encodePacked(\n            airnodeId,\n            msg.sender,\n            fulfillAddress,\n            fulfillFunctionId\n            ));\n        require(\n            incomingFulfillmentParameters == requestIdToFulfillmentParameters[requestId],\n            \"No such request\"\n            );\n        _;\n    }\n\n    /// @notice Called by the client to make a regular request. A regular\n    /// request refers to a template for the Airnode, endpoint and parameters.\n    /// @param templateId Template ID from TemplateStore\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param designatedWallet Designated wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the client in addition to the\n    /// parameters in the template.\n    /// @return requestId Request ID\n    function makeRequest(\n        bytes32 templateId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 requestId)\n    {\n        require(\n            requesterIndexToClientAddressToEndorsementStatus[requesterIndex][msg.sender],\n            \"Client not endorsed by requester\"\n            );\n        uint256 clientNoRequests = clientAddressToNoRequests[msg.sender];\n        requestId = keccak256(abi.encode(\n            clientNoRequests,\n            block.chainid,\n            msg.sender,\n            templateId,\n            parameters\n            ));\n        bytes32 airnodeId = templates[templateId].airnodeId;\n        requestIdToFulfillmentParameters[requestId] = keccak256(abi.encodePacked(\n            airnodeId,\n            designatedWallet,\n            fulfillAddress,\n            fulfillFunctionId\n            ));\n        emit ClientRequestCreated(\n            airnodeId,\n            requestId,\n            clientNoRequests,\n            block.chainid,\n            msg.sender,\n            templateId,\n            requesterIndex,\n            designatedWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        clientAddressToNoRequests[msg.sender]++;\n    }\n\n    /// @notice Called by the client to make a full request. A full request\n    /// provides all of its parameters as arguments and does not refer to a\n    /// template.\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param requesterIndex Requester index from RequesterStore\n    /// @param designatedWallet Designated wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    /// @return requestId Request ID\n    function makeFullRequest(\n        bytes32 airnodeId,\n        bytes32 endpointId,\n        uint256 requesterIndex,\n        address designatedWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 requestId)\n    {\n        require(\n            requesterIndexToClientAddressToEndorsementStatus[requesterIndex][msg.sender],\n            \"Client not endorsed by requester\"\n            );\n        uint256 clientNoRequests = clientAddressToNoRequests[msg.sender];\n        requestId = keccak256(abi.encode(\n            clientNoRequests,\n            block.chainid,\n            msg.sender,\n            endpointId,\n            parameters\n            ));\n        requestIdToFulfillmentParameters[requestId] = keccak256(abi.encodePacked(\n            airnodeId,\n            designatedWallet,\n            fulfillAddress,\n            fulfillFunctionId\n            ));\n        emit ClientFullRequestCreated(\n            airnodeId,\n            requestId,\n            clientNoRequests,\n            block.chainid,\n            msg.sender,\n            endpointId,\n            requesterIndex,\n            designatedWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        clientAddressToNoRequests[msg.sender]++;\n    }\n\n    /// @notice Called by Airnode to fulfill the request (regular or full)\n    /// @dev `statusCode` being zero indicates a successful fulfillment, while\n    /// non-zero values indicate error (the meanings of these values are\n    /// implementation-dependent).\n    /// The data is ABI-encoded as a `bytes` type, with its format depending on\n    /// the request specifications.\n    /// @param requestId Request ID\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param statusCode Status code of the fulfillment\n    /// @param data Fulfillment data\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfill(\n        bytes32 requestId,\n        bytes32 airnodeId,\n        uint256 statusCode,\n        bytes calldata data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        override\n        onlyCorrectFulfillmentParameters(\n            requestId,\n            airnodeId,\n            fulfillAddress,\n            fulfillFunctionId\n            )\n        returns (\n            bool callSuccess,\n            bytes memory callData\n        )\n    {\n        delete requestIdToFulfillmentParameters[requestId];\n        emit ClientRequestFulfilled(\n            airnodeId,\n            requestId,\n            statusCode,\n            data\n            );\n        (callSuccess, callData) = fulfillAddress.call(  // solhint-disable-line\n            abi.encodeWithSelector(fulfillFunctionId, requestId, statusCode, data)\n            );\n    }\n\n    /// @notice Called by Airnode if the request cannot be fulfilled\n    /// @dev Airnode should fall back to this if a request cannot be fulfilled\n    /// because fulfill() reverts\n    /// @param requestId Request ID\n    /// @param airnodeId Airnode ID from AirnodeParameterStore\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    function fail(\n        bytes32 requestId,\n        bytes32 airnodeId,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        override\n        onlyCorrectFulfillmentParameters(\n            requestId,\n            airnodeId,\n            fulfillAddress,\n            fulfillFunctionId\n            )\n    {\n        delete requestIdToFulfillmentParameters[requestId];\n        // Failure is recorded so that it can be checked externally\n        requestWithIdHasFailed[requestId] = true;\n        emit ClientRequestFailed(\n            airnodeId,\n            requestId\n            );\n    }\n}\n"
    },
    "contracts/dapis/reducers/Mean.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./Reducer.sol\";\n\n/// @title Mean reduction contract\n/// @notice Mean reduction result can be skewed even with a single misreport.\n/// Therefore, it should either be used in special circumstances or as a part\n/// of a more complex reduction method such as MeanMedianHybrid.sol.\n/// @dev Note that there is a potential for overflow while summing large enough\n/// values. If that is a probability, use Median.sol instead.\ncontract Mean is Reducer {\n    /// @notice Reduces the array of values by computing their mean\n    /// @param values Values to be reduced\n    function reduceInPlace(int256[] memory values)\n        internal\n        view\n        virtual\n        override\n        returns (int256)\n    {\n        int256 mean = 0;\n        for (uint256 i = 0; i < values.length; i++) {\n          mean += values[i];\n        }\n        mean /= int256(values.length);\n        return mean;\n    }\n}\n"
    },
    "contracts/dapis/reducers/Reducer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/// @title The abstract contract that generalizes reduction methods\n/// @notice Reduction method implementations should inherit this contract\nabstract contract Reducer {\n    /// @notice Called internally by the dAPI contract to reduce an array of\n    /// values\n    /// @dev It is not guaranteed that `values` will not be changed after this\n    /// method runs\n    /// @param values Values to be reduced\n    function reduceInPlace(int256[] memory values)\n        internal\n        view\n        virtual\n        returns (int256);\n}\n"
    },
    "contracts/dapis/reducers/MeanMedianHybrid.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./Mean.sol\";\nimport \"./Median.sol\";\nimport \"./Reducer.sol\";\n\n/// @title Mean-median hybrid reduction contract\n/// @notice Mean is accurate but not robust. Median is inaccurate but robust.\n/// Mean-median hybrid uses mean under normal circumstances for accuracy, but\n/// falls back to median if there is a large enough discrepancy between mean\n/// and median. Since the calculation of mean and its validation takes O(n)\n/// time, it is more scalable than bare median under normal circumstances\n/// (where mean will be similar to median).\n/// @dev Even though the types are defined as `int256` for consistency, this\n/// method is more suitable for similarly values. For example, consider the\n/// values [-100, -4, 1, 1, 1, 1, 100]. The mean of these values is 0 and the\n/// median is 1. Here, even though the mean is very close to the median, upper\n/// and lower tolerances will be zero, which means the reduction will fall\n/// back to median. Therefore, consider using Median.sol instead for values\n/// with potentially alternating signs.\n/// Note that there is a potential for overflow while summing large enough\n/// values (in `Mean.aggregateInplace`). If that is a probability, use\n/// Median.sol instead.\ncontract MeanMedianHybrid is Mean, Median {\n    /// @notice Percentages are represented by multiplying by 1,000,000 (1e6)\n    int256 public constant HUNDRED_PERCENT = 100e6;\n    /// @notice Reduction will fall back to median if the median is not with\n    /// a [-toleranceInPercentages, toleranceInPercentages] neighborhood of the\n    /// mean\n    int256 public toleranceInPercentages;\n\n    /// @dev Reverts if the percentage value is not valid\n    /// @param percentageValue A percentage value represented by multiplying by\n    /// 1,000,000 (1e6)\n    modifier onlyValidPercentage(int256 percentageValue)\n    {\n        require(\n            percentageValue >= 0 && percentageValue <= HUNDRED_PERCENT,\n            \"Invalid percentage\"\n            );\n        _;\n    }\n\n    /// @param _toleranceInPercentages Tolerance in percentages\n    constructor (int256 _toleranceInPercentages)\n        onlyValidPercentage(_toleranceInPercentages)\n    {\n        toleranceInPercentages = _toleranceInPercentages;\n    }\n\n    /// @notice Called by the owner to set the tolerance\n    /// @dev This should be set high enough that the reduction does not fall\n    /// back to median unless there is a misreport among the values to be\n    /// reduced\n    /// @param _toleranceInPercentages Tolerance in percentages\n    function setTolerance (int256 _toleranceInPercentages)\n        external\n        onlyValidPercentage(_toleranceInPercentages)\n        // onlyOwner\n    {\n        toleranceInPercentages = _toleranceInPercentages;\n    }\n\n    /// @notice Reduces the array of values by computing their mean, checking\n    /// if the mean is similar enough to median, and computing the median\n    /// instead if it is not\n    /// @param values Values to be reduced\n    function reduceInPlace(int256[] memory values)\n        internal\n        view\n        virtual\n        override(Mean, Median)\n        returns (int256)\n    {\n        int256 mean = Mean.reduceInPlace(values);\n        // Test the mean for validity\n        int256 upperTolerance = mean * (HUNDRED_PERCENT + toleranceInPercentages) / HUNDRED_PERCENT;\n        int256 lowerTolerance = mean * (HUNDRED_PERCENT - toleranceInPercentages) / HUNDRED_PERCENT;\n        uint256 upperToleranceValidityCount;\n        uint256 lowerToleranceValidityCount;\n        for (uint256 i = 0; i < values.length; i++) {\n            if (upperTolerance >= values[i]) {\n                upperToleranceValidityCount++;\n            }\n            if (lowerTolerance <= values[i]) {\n                lowerToleranceValidityCount++;\n            }\n        }\n        if (upperToleranceValidityCount >= values.length / 2) {\n            if (lowerToleranceValidityCount >= values.length / 2) {\n                return mean;\n            }\n        }\n        // Fall back to median if the mean is not valid\n        return Median.reduceInPlace(values);\n    }\n}\n"
    },
    "contracts/dapis/reducers/Median.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./SelectK.sol\";\nimport \"./Reducer.sol\";\n\n/// @title Median reduction contract\n/// @notice Median reduction is robust against misreports, yet it is not as\n/// numerically accurate as mean beacuse it depends on a single data point. It\n/// should be used when numerical accuracy is not critical or as a part of a\n/// more complex reduction method such as MeanMedianHybrid.sol.\ncontract Median is SelectK, Reducer {\n    /// @notice Reduces the array of values by computing their median\n    /// @param values Values to be reduced\n    function reduceInPlace(int256[] memory values)\n        internal\n        view\n        virtual\n        override\n        returns (int256)\n    {\n        if (values.length % 2 != 1) {\n            return computeInPlace(values, values.length / 2 + 1);\n        }\n        else {\n            (int256 mid1, int256 mid2) = compute2InPlace(values, values.length / 2 - 1);\n            return (mid1 + mid2) / 2;\n        }\n    }\n}\n"
    },
    "contracts/dapis/reducers/SelectK.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/// @title A contract for selecting the kth smallest element in an array of uints.\n/// @author Sasa Milic - <sasa@api3.org>\ncontract SelectK {\n  \n  // maximum length of an array that `_medianSmallArray` can handle\n  uint256 constant public SMALL_ARRAY_MAX_LENGTH = 16;\n    \n  // EXTERNAL FUNCTIONS\n  \n  /// Returns the kth smallest element in an array of signed ints without\n  /// modifying the input array. \n  /// @param arr An array of signed integers.\n  /// @param k the rank of the element\n  /// @return the kth smallest element in `arr` \n  function compute\n  (\n    int256[] memory arr,\n    uint256 k\n  )\n    external\n    pure\n    returns (int256)\n  {\n    require(k <= arr.length - 1, \"k must be a valid index in arr\");\n    return computeInPlace(copy(arr), k);\n  }\n\n  /// Returns the kth and (k+1)st smallest elements in an array of signed ints without\n  /// modifying the input array.\n  /// @dev This is for when one wants to compute the exact median of an\n  ///      even-length array. It's more gas efficient than calling `compute` twice. \n  /// @param arr An array of signed integers.\n  /// @param k the rank of the element\n  /// @return a tuple containing the kth and (k+1)st smallest elements in `arr`,\n  ///         respectively \n  function compute2\n  (\n    int256[] memory arr,\n    uint256 k\n  )\n    external\n    pure\n    returns (int256, int256)\n  {\n    require(k <= arr.length - 2, \"k must be a valid index in arr\");\n    return compute2InPlace(copy(arr), k);\n  }\n\n  /// Returns the kth smallest element in an array of signed ints.\n  /// @dev The input array `arr` may be modified during the computation.\n  /// @param arr An array of unsigned integers.\n  /// @param k the rank of the element\n  /// @return the kth smallest elements in `arr` \n  function computeInPlace\n  (\n    int256[] memory arr,\n    uint256 k\n  )\n    public\n    pure\n    returns (int256)\n  {\n    require(k <= arr.length - 1, \"k must be a valid index in arr\");\n    if (arr.length <= SMALL_ARRAY_MAX_LENGTH) {\n      return selectKsmallArray(arr, k);\n    }\n    (uint256 idx1,) = quickSelect(arr, 0, arr.length - 1, k, false);\n    return arr[idx1];\n  }\n\n  /// Returns the kth and (k+1)st smallest elements in an array of signed ints without\n  /// modifying the input array.\n  /// @dev This is for when one wants to compute the exact median of an\n  ///      even-length array. It's more gas efficient than calling `compute` twice.\n  ///      Note that array `arr` may be modified during the computation. \n  /// @param arr An array of signed integers.\n  /// @param k the rank of the element\n  /// @return a tuple containing the kth and (k+1)st smallest elements in `arr`,\n  ///         respectively \n  function compute2InPlace\n  (\n    int256[] memory arr,\n    uint256 k\n  )\n    public\n    pure\n    returns (int256, int256)\n  {\n    require(k <= arr.length - 2, \"k must be a valid index in arr\");\n    if (arr.length <= SMALL_ARRAY_MAX_LENGTH) {\n      int256 x1 = selectKsmallArray(arr, k);\n      int256 x2 = arr[k + 1];\n      return (x1, x2);\n    }\n    (uint256 idx1, uint256 idx2) = quickSelect(arr, 0, arr.length - 1, k, true);\n    return (arr[idx1], arr[idx2]);\n  }\n\n  // PRIVATE FUNCTIONS\n\n  /// Select the index of the kth element in an array.\n  /// @dev This function may modify array.\n  /// @param arr an array of uints.\n  /// @param lo the left index to begin search.\n  /// @param hi the right index to begin search.\n  /// @param k the rank of the element\n  /// @param selectKplusOne a bool representing whether the function should\n  ///                       return the (k+1)st element or not.\n  /// @return a tuple (i, j) where i and j are the indices of the kth and\n  ///         (k+1)st elements of `arr`, respectively. In the case where\n  ///         `selectKplusOne` is false, the tuple returned is (i, 0).\n   function quickSelect\n  (\n    int256[] memory arr,\n    uint256 lo,\n    uint256 hi,\n    uint256 k,\n    bool selectKplusOne\n  )\n    private\n    pure\n    returns (uint256, uint256)\n  {\n    if (lo == hi) {return (k, 0);}\n   \n    uint256 pivotIdx = partition(arr, lo, hi);\n\n    uint256 idx1;\n    uint256 idx2;\n\n    if (k == pivotIdx) {\n      idx1 = pivotIdx;\n    } else if (k < pivotIdx){\n      (idx1, idx2) = quickSelect(arr, lo, pivotIdx - 1, k, false);\n    } else {\n      (idx1, idx2) = quickSelect(arr, pivotIdx + 1, hi, k, false);\n    }\n    if (!selectKplusOne) {\n      return (idx1, 0);\n    }\n    // In order to find (k+1)th element,\n    // find minimum in right partition of array\n    idx2 = idx1 + 1;\n    for (uint i=idx1+2; i<arr.length; i++) {\n      if (arr[i] < arr[idx2]) {\n        idx2 = i;\n      }\n    }\n    return (idx1, idx2);\n  }\n\n  \n  /// Partitions the array in-place using a modified Hoare's partitioning\n  /// scheme. Only elements between indices `lo` and `high` (inclusive) will be\n  /// partitioned.\n  /// @dev Hoare's algorithm is modified in order to return the index of the\n  ///      pivot element.\n  /// @return the index of the pivot\n  function partition\n  (\n    int256[] memory arr,\n    uint256 lo,\n    uint256 hi\n  )\n    private\n    pure\n    returns (uint256)\n  {\n    if (lo == hi) {return lo;}\n    \n    int pivot = arr[lo];\n\n    uint i = lo;\n    uint j = hi + 1;\n \n    while (true) {\n      do {\n        i++;\n      } while (i < arr.length && arr[i] < pivot);\n      do {\n        j--;\n      } while (arr[j] > pivot);\n      if (i >= j) {\n        // swap with pivot\n        (arr[lo], arr[j]) = (arr[j], arr[lo]);\n        return j;\n      } \n      (arr[i], arr[j]) = (arr[j], arr[i]);\n    }\n  }\n\n  /// Return the kth element of a small array (at most length 16).\n  /// @dev The input array `arr` may be modified during the computation.\n  /// @param arr an array of signed integers (at most length 16)\n  /// @return the kth smallest element in `arr`\n  function selectKsmallArray\n  (\n    int256[] memory arr,\n    uint256 k\n  )\n      private\n      pure\n      returns (int256)\n  {\n    if (arr.length == 2) {\n      condSwap(arr, 0, 1);\n    }\n    else if (arr.length == 3) {\n      condSwap(arr, 0, 1); condSwap(arr, 1, 2); condSwap(arr, 0, 1);\n    }\n    else if (arr.length == 4) {\n      condSwap(arr, 0, 1); condSwap(arr, 2, 3); condSwap(arr, 1, 3);\n      condSwap(arr, 0, 2); condSwap(arr, 1, 2);\n    }\n    else if (arr.length == 5) {\n      condSwap(arr, 1, 2); condSwap(arr, 3, 4); condSwap(arr, 1, 3);\n      condSwap(arr, 0, 2); condSwap(arr, 2, 4); condSwap(arr, 0, 3);\n      condSwap(arr, 0, 1); condSwap(arr, 2, 3); condSwap(arr, 1, 2);\n    }\n    else if (arr.length == 6) {\n      condSwap(arr, 0, 1); condSwap(arr, 2, 3); condSwap(arr, 4, 5);\n      condSwap(arr, 1, 3); condSwap(arr, 3, 5); condSwap(arr, 1, 3);\n      condSwap(arr, 2, 4); condSwap(arr, 0, 2); condSwap(arr, 2, 4);\n      condSwap(arr, 3, 4); condSwap(arr, 1, 2); condSwap(arr, 2, 3);\n    }\n    else if (arr.length == 7) {\n      condSwap(arr, 1, 2); condSwap(arr, 3, 4); condSwap(arr, 5, 6);\n      condSwap(arr, 0, 2); condSwap(arr, 4, 6); condSwap(arr, 3, 5);\n      condSwap(arr, 2, 6); condSwap(arr, 1, 5); condSwap(arr, 0, 4);\n      condSwap(arr, 2, 5); condSwap(arr, 0, 3); condSwap(arr, 2, 4);\n      condSwap(arr, 1, 3); condSwap(arr, 0, 1); condSwap(arr, 2, 3);\n      condSwap(arr, 4, 5);\n    }\n    else if (arr.length == 8) {\n      condSwap(arr, 0, 7); condSwap(arr, 1, 6); condSwap(arr, 2, 5);\n      condSwap(arr, 3, 4); condSwap(arr, 0, 3); condSwap(arr, 4, 7);\n      condSwap(arr, 1, 2); condSwap(arr, 5, 6); condSwap(arr, 0, 1);\n      condSwap(arr, 2, 3); condSwap(arr, 4, 5); condSwap(arr, 6, 7);\n      condSwap(arr, 3, 5); condSwap(arr, 2, 4); condSwap(arr, 1, 2);\n      condSwap(arr, 3, 4); condSwap(arr, 5, 6); condSwap(arr, 2, 3);\n      condSwap(arr, 4, 5);\n    }\n    else if (arr.length == 9) {\n      condSwap(arr, 1, 8); condSwap(arr, 2, 7); condSwap(arr, 3, 6);\n      condSwap(arr, 4, 5); condSwap(arr, 1, 4); condSwap(arr, 5, 8);\n      condSwap(arr, 0, 2); condSwap(arr, 6, 7); condSwap(arr, 2, 6);\n      condSwap(arr, 7, 8); condSwap(arr, 0, 3); condSwap(arr, 4, 5);\n      condSwap(arr, 0, 1); condSwap(arr, 3, 5); condSwap(arr, 6, 7);\n      condSwap(arr, 2, 4); condSwap(arr, 1, 3); condSwap(arr, 5, 7);\n      condSwap(arr, 4, 6); condSwap(arr, 1, 2); condSwap(arr, 3, 4);\n      condSwap(arr, 5, 6); condSwap(arr, 7, 8); condSwap(arr, 2, 3);\n      condSwap(arr, 4, 5);\n    }\n    else if (arr.length == 10) {\n      condSwap(arr, 0, 1);  condSwap(arr, 2, 3); condSwap(arr, 4, 5);\n      condSwap(arr, 6, 7);  condSwap(arr, 8, 9); condSwap(arr, 4, 9);\n      condSwap(arr, 0, 5);  condSwap(arr, 1, 8); condSwap(arr, 3, 7);\n      condSwap(arr, 2, 6);  condSwap(arr, 0, 2); condSwap(arr, 3, 6);\n      condSwap(arr, 7, 9);  condSwap(arr, 1, 4); condSwap(arr, 5, 8);\n      condSwap(arr, 0, 1);  condSwap(arr, 2, 7); condSwap(arr, 8, 9);\n      condSwap(arr, 4, 6);  condSwap(arr, 3, 5); condSwap(arr, 2, 4);\n      condSwap(arr, 6, 8);  condSwap(arr, 1, 3); condSwap(arr, 5, 7);\n      condSwap(arr, 1, 2);  condSwap(arr, 3, 4); condSwap(arr, 5, 6);\n      condSwap(arr, 7, 8);  condSwap(arr, 2, 3); condSwap(arr, 4, 5);\n      condSwap(arr, 6, 7);\n    }\n    else if (arr.length == 11) {\n      condSwap(arr, 0, 9);  condSwap(arr, 1, 8);  condSwap(arr, 2, 7);\n      condSwap(arr, 3, 6);  condSwap(arr, 4, 5);  condSwap(arr, 0, 3);\n      condSwap(arr, 1, 2);  condSwap(arr, 4, 10); condSwap(arr, 6, 9);\n      condSwap(arr, 7, 8);  condSwap(arr, 0, 1);  condSwap(arr, 2, 3);\n      condSwap(arr, 5, 8);  condSwap(arr, 9, 10); condSwap(arr, 6, 7);\n      condSwap(arr, 1, 2);  condSwap(arr, 4, 6);  condSwap(arr, 8, 10);\n      condSwap(arr, 5, 9);  condSwap(arr, 0, 4);  condSwap(arr, 7, 8);\n      condSwap(arr, 1, 5);  condSwap(arr, 2, 9);  condSwap(arr, 3, 6);\n      condSwap(arr, 1, 4);  condSwap(arr, 5, 7);  condSwap(arr, 2, 3);\n      condSwap(arr, 6, 9);  condSwap(arr, 2, 4);  condSwap(arr, 6, 7);\n      condSwap(arr, 8, 9);  condSwap(arr, 3, 5);  condSwap(arr, 3, 4);\n      condSwap(arr, 5, 6);  condSwap(arr, 7, 8);\n    }\n    else if (arr.length == 12) {\n      condSwap(arr, 0, 6);   condSwap(arr, 1, 7);  condSwap(arr, 2, 8);\n      condSwap(arr, 3, 9);   condSwap(arr, 4, 10); condSwap(arr, 5, 11);\n      condSwap(arr, 0, 3);   condSwap(arr, 1, 4);  condSwap(arr, 2, 5);\n      condSwap(arr, 6, 9);   condSwap(arr, 7, 10); condSwap(arr, 8, 11);\n      condSwap(arr, 0, 1);   condSwap(arr, 3, 4);  condSwap(arr, 5, 8);\n      condSwap(arr, 10, 11); condSwap(arr, 6, 7);  condSwap(arr, 1, 2);\n      condSwap(arr, 3, 6);   condSwap(arr, 7, 8);  condSwap(arr, 9, 10);\n      condSwap(arr, 4, 5);   condSwap(arr, 0, 1);  condSwap(arr, 2, 9);\n      condSwap(arr, 10, 11); condSwap(arr, 3, 4);  condSwap(arr, 5, 8);\n      condSwap(arr, 6, 7);   condSwap(arr, 1, 3);  condSwap(arr, 4, 7);\n      condSwap(arr, 8, 10);  condSwap(arr, 2, 6);  condSwap(arr, 5, 9);\n      condSwap(arr, 2, 3);   condSwap(arr, 4, 6);  condSwap(arr, 8, 9);\n      condSwap(arr, 5, 7);   condSwap(arr, 3, 4);  condSwap(arr, 5, 6);\n      condSwap(arr, 7, 8);\n    }\n    else if (arr.length == 13) {\n      condSwap(arr, 1, 12); condSwap(arr, 2, 11);  condSwap(arr, 3, 10);\n      condSwap(arr, 4, 9);  condSwap(arr, 5, 8);   condSwap(arr, 6, 7);\n      condSwap(arr, 0, 5);  condSwap(arr, 1, 4);   condSwap(arr, 2, 3);\n      condSwap(arr, 9, 12); condSwap(arr, 10, 11); condSwap(arr, 3, 6);\n      condSwap(arr, 7, 10); condSwap(arr, 0, 1);   condSwap(arr, 4, 5);\n      condSwap(arr, 8, 9);  condSwap(arr, 1, 7);   condSwap(arr, 9, 10);\n      condSwap(arr, 2, 8);  condSwap(arr, 3, 4);   condSwap(arr, 5, 11);\n      condSwap(arr, 6, 12); condSwap(arr, 0, 3);   condSwap(arr, 4, 9);\n      condSwap(arr, 1, 2);  condSwap(arr, 5, 8);   condSwap(arr, 11, 12);\n      condSwap(arr, 6, 7);  condSwap(arr, 0, 1);   condSwap(arr, 2, 3);\n      condSwap(arr, 4, 7);  condSwap(arr, 10, 11); condSwap(arr, 5, 9);\n      condSwap(arr, 6, 8);  condSwap(arr, 1, 2);   condSwap(arr, 3, 5);\n      condSwap(arr, 8, 10); condSwap(arr, 11, 12); condSwap(arr, 4, 6);\n      condSwap(arr, 7, 9);  condSwap(arr, 3, 4);   condSwap(arr, 5, 6);\n      condSwap(arr, 7, 8);  condSwap(arr, 9, 10);  condSwap(arr, 2, 3);\n      condSwap(arr, 4, 5);  condSwap(arr, 6, 7);   condSwap(arr, 8, 9);\n      condSwap(arr, 10, 11);\n    }\n    else if (arr.length == 14) {\n      condSwap(arr, 0, 13);  condSwap(arr, 1, 12); condSwap(arr, 2, 11);\n      condSwap(arr, 3, 10);  condSwap(arr, 4, 9);  condSwap(arr, 5, 8);\n      condSwap(arr, 6, 7);   condSwap(arr, 0, 5);  condSwap(arr, 1, 4);\n      condSwap(arr, 2, 3);   condSwap(arr, 8, 13); condSwap(arr, 9, 12);\n      condSwap(arr, 10, 11); condSwap(arr, 3, 6);  condSwap(arr, 7, 10);\n      condSwap(arr, 0, 1);   condSwap(arr, 4, 5);  condSwap(arr, 8, 9);\n      condSwap(arr, 12, 13); condSwap(arr, 1, 7);  condSwap(arr, 9, 10);\n      condSwap(arr, 2, 8);   condSwap(arr, 3, 4);  condSwap(arr, 5, 11);\n      condSwap(arr, 6, 12);  condSwap(arr, 0, 3);  condSwap(arr, 4, 9);\n      condSwap(arr, 10, 13); condSwap(arr, 1, 2);  condSwap(arr, 5, 8);\n      condSwap(arr, 11, 12); condSwap(arr, 6, 7);  condSwap(arr, 0, 1);\n      condSwap(arr, 2, 3);   condSwap(arr, 4, 7);  condSwap(arr, 10, 11);\n      condSwap(arr, 12, 13); condSwap(arr, 5, 9);  condSwap(arr, 6, 8);\n      condSwap(arr, 1, 2);   condSwap(arr, 3, 5);  condSwap(arr, 8, 10);\n      condSwap(arr, 11, 12); condSwap(arr, 4, 6);  condSwap(arr, 7, 9);\n      condSwap(arr, 3, 4);   condSwap(arr, 5, 6);  condSwap(arr, 7, 8);\n      condSwap(arr, 9, 10);  condSwap(arr, 2, 3);  condSwap(arr, 4, 5);\n      condSwap(arr, 6, 7);   condSwap(arr, 8, 9);  condSwap(arr, 10, 11);\n    }\n    else if (arr.length == 15) {\n      condSwap(arr, 1, 14);  condSwap(arr, 2, 13);  condSwap(arr, 3, 12);\n      condSwap(arr, 4, 11);  condSwap(arr, 5, 10);  condSwap(arr, 6, 9);\n      condSwap(arr, 7, 8);   condSwap(arr, 0, 7);   condSwap(arr, 1, 6);\n      condSwap(arr, 2, 5);   condSwap(arr, 3, 4);   condSwap(arr, 9, 14);\n      condSwap(arr, 10, 13); condSwap(arr, 11, 12); condSwap(arr, 0, 3);\n      condSwap(arr, 4, 7);   condSwap(arr, 8, 11);  condSwap(arr, 1, 2);\n      condSwap(arr, 5, 6);   condSwap(arr, 9, 10);  condSwap(arr, 13, 14);\n      condSwap(arr, 0, 1);   condSwap(arr, 2, 8);   condSwap(arr, 10, 11);\n      condSwap(arr, 3, 9);   condSwap(arr, 4, 5);   condSwap(arr, 6, 12);\n      condSwap(arr, 7, 13);  condSwap(arr, 1, 4);   condSwap(arr, 5, 10);\n      condSwap(arr, 11, 14); condSwap(arr, 2, 3);   condSwap(arr, 6, 9);\n      condSwap(arr, 12, 13); condSwap(arr, 7, 8);   condSwap(arr, 1, 2);\n      condSwap(arr, 3, 4);   condSwap(arr, 5, 8);   condSwap(arr, 11, 12);\n      condSwap(arr, 13, 14); condSwap(arr, 6, 10);  condSwap(arr, 7, 9);\n      condSwap(arr, 2, 3);   condSwap(arr, 4, 6);   condSwap(arr, 9, 11);\n      condSwap(arr, 12, 13); condSwap(arr, 5, 7);   condSwap(arr, 8, 10);\n      condSwap(arr, 4, 5);   condSwap(arr, 6, 7);   condSwap(arr, 8, 9);\n      condSwap(arr, 10, 11); condSwap(arr, 3, 4);   condSwap(arr, 5, 6);\n      condSwap(arr, 7, 8);   condSwap(arr, 9, 10);  condSwap(arr, 11, 12);\n    }\n    else if (arr.length == 16) {\n      condSwap(arr, 0, 15);  condSwap(arr, 1, 14);  condSwap(arr, 2, 13);\n      condSwap(arr, 3, 12);  condSwap(arr, 4, 11);  condSwap(arr, 5, 10);\n      condSwap(arr, 6, 9);   condSwap(arr, 7, 8);   condSwap(arr, 0, 7);\n      condSwap(arr, 1, 6);   condSwap(arr, 2, 5);   condSwap(arr, 3, 4);\n      condSwap(arr, 8, 15);  condSwap(arr, 9, 14);  condSwap(arr, 10, 13);\n      condSwap(arr, 11, 12); condSwap(arr, 0, 3);   condSwap(arr, 4, 7);\n      condSwap(arr, 8, 11);  condSwap(arr, 12, 15); condSwap(arr, 1, 2);\n      condSwap(arr, 5, 6);   condSwap(arr, 9, 10);  condSwap(arr, 13, 14);\n      condSwap(arr, 0, 1);   condSwap(arr, 2, 8);   condSwap(arr, 10, 11);\n      condSwap(arr, 14, 15); condSwap(arr, 3, 9);   condSwap(arr, 4, 5);\n      condSwap(arr, 6, 12);  condSwap(arr, 7, 13);  condSwap(arr, 1, 4);\n      condSwap(arr, 5, 10);  condSwap(arr, 11, 14); condSwap(arr, 2, 3);\n      condSwap(arr, 6, 9);   condSwap(arr, 12, 13); condSwap(arr, 7, 8);\n      condSwap(arr, 1, 2);   condSwap(arr, 3, 4);   condSwap(arr, 5, 8);\n      condSwap(arr, 11, 12); condSwap(arr, 13, 14); condSwap(arr, 6, 10);\n      condSwap(arr, 7, 9);   condSwap(arr, 2, 3);   condSwap(arr, 4, 6);\n      condSwap(arr, 9, 11);  condSwap(arr, 12, 13); condSwap(arr, 5, 7);\n      condSwap(arr, 8, 10);  condSwap(arr, 4, 5);   condSwap(arr, 6, 7);\n      condSwap(arr, 8, 9);   condSwap(arr, 10, 11); condSwap(arr, 3, 4);\n      condSwap(arr, 5, 6);   condSwap(arr, 7, 8);   condSwap(arr, 9, 10);\n      condSwap(arr, 11, 12);\n    }\n    return arr[k];\n  }\n\n  /// condSwap two elements of an array iff the first element\n  /// is greater than the second.\n  /// @param arr an array of unsigned integers\n  /// @param i the first index\n  /// @param j the second index\n  function condSwap\n  (\n    int256[] memory arr,\n    uint256 i,\n    uint256 j\n  )\n    private\n    pure\n  {\n    assert(i < j);\n    if (arr[i] > arr[j]) {(arr[i], arr[j]) = (arr[j], arr[i]);}\n  }\n\n  /// Make an in-memory copy of an array\n  /// @param arr The array to be copied.\n  function copy\n  (\n    int256[] memory arr\n  )\n    private\n    pure\n    returns(int256[] memory)\n  {\n    int256[] memory arr2 = new int256[](arr.length);\n    for (uint i = 0; i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\n"
    },
    "contracts/dapis/RrpDapi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./reducers/Reducer.sol\";\n\n// A stub for an RRP dAPI contract\n// When the user wants to deploy a dAPI contract, they inherit the specific\n// reducer contract such as:\n//       contract myRrpDapi is rrpDapi, Median {\n//           // Any specific implementation required\n//       }\nabstract contract RrpDapi is Reducer {\n    // TODO: Implement\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
