{
  "language": "Solidity",
  "sources": {
    "contracts/adminnable/Adminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IAdminnable.sol\";\n\n/// @title Contract that implements multiple levels of admins\ncontract Adminnable is IAdminnable {\n    /// @notice Meta-admin ranks higher than all admins\n    address public override metaAdmin;\n\n    /// @notice Called to get the rank of an admin\n    /// @dev Higher ranks have more authority\n    mapping(address => uint256) public override adminToRank;\n\n    /// @dev Reverts if the caller's rank is not greater than or equal to\n    /// `rank`. `metaAdmin` always satisfies rank requirements.\n    /// @param rank Rank caller's rank will be compared to\n    modifier onlyWithRank(uint256 rank) {\n        require(\n            adminToRank[msg.sender] >= rank || msg.sender == metaAdmin,\n            \"Caller ranked low\"\n        );\n        _;\n    }\n\n    /// @dev Deployer needs to transfer meta-adminship afterwards\n    constructor() {\n        metaAdmin = msg.sender;\n    }\n\n    /// @notice Called by the meta-admin to transfer its status to another\n    /// address\n    /// @param metaAdmin_ New meta-admin\n    function transferMetaAdminStatus(address metaAdmin_) external override {\n        require(msg.sender == metaAdmin, \"Caller not metaAdmin\");\n        require(metaAdmin_ != address(0), \"Zero address\");\n        metaAdmin = metaAdmin_;\n        emit TransferredMetaAdminStatus(metaAdmin_);\n    }\n\n    /// @notice Called by an admin of higher rank to set the rank of an admin\n    /// of lower rank\n    /// @param targetAdmin Target admin address\n    /// @param newRank Rank to be set\n    function setRank(address targetAdmin, uint256 newRank)\n        external\n        override\n        onlyWithRank(max(adminToRank[targetAdmin], newRank) + 1)\n    {\n        require(targetAdmin != address(0), \"Target admin zero\");\n        adminToRank[targetAdmin] = newRank;\n        emit SetRank(msg.sender, targetAdmin, newRank);\n    }\n\n    /// @notice Called by an admin to decrease its rank\n    /// @param newRank Rank to be set\n    function decreaseSelfRank(uint256 newRank)\n        external\n        override\n        onlyWithRank(newRank + 1)\n    {\n        adminToRank[msg.sender] = newRank;\n        emit DecreasedSelfRank(msg.sender, newRank);\n    }\n\n    /// @notice Called internally to compute the maximum between two unsigned\n    /// integers\n    /// @param a First unsigned integer\n    /// @param b Second unsigned integer\n    /// @return Larger of the two unsigned integers\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/adminnable/interfaces/IAdminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAdminnable {\n    event TransferredMetaAdminStatus(address indexed metaAdmin);\n\n    event SetRank(\n        address indexed callerAdmin,\n        address indexed targetAdmin,\n        uint256 newRank\n    );\n\n    event DecreasedSelfRank(address indexed admin, uint256 newRank);\n\n    function transferMetaAdminStatus(address metaAdmin_) external;\n\n    function setRank(address targetAdmin, uint256 newRank) external;\n\n    function decreaseSelfRank(uint256 newRank) external;\n\n    function metaAdmin() external view returns (address);\n\n    function adminToRank(address admin) external view returns (uint256);\n}\n"
    },
    "contracts/rrp/requesters/RrpBeaconServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/Adminnable.sol\";\nimport \"../../adminnable/Whitelister.sol\";\nimport \"./RrpRequester.sol\";\nimport \"./interfaces/IRrpBeaconServer.sol\";\n\n/// @title The contract that serves beacons using Airnode RRP\n/// @notice A beacon is a live data point associated with a template ID. This\n/// is suitable where the more recent data point is always more favorable,\n/// e.g., in the context of an asset price data feed. Another definition of\n/// beacons are one-Airnode data feeds that can be used individually or\n/// combined to build decentralized data feeds.\n/// @dev This contract casts the reported data point to `int224`. If this is\n/// a problem (because the reported data may not fit into 224 bits or it is of\n/// a completely different type such as `bytes32`), do not use this contract\n/// and implement a customized version instead.\n/// The contract casts the timestamps to `uint32`, which means it will not work\n/// work past-2038 in the current form. If this is an issue, consider casting\n/// the timestampts to a larger type.\ncontract RrpBeaconServer is\n    Adminnable,\n    Whitelister,\n    RrpRequester,\n    IRrpBeaconServer\n{\n    enum AdminRank {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n    }\n\n    struct Beacon {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Called to check if a sponsor has permitted an account to\n    /// request updates at this contract\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToUpdateRequesterToPermissionStatus;\n\n    mapping(bytes32 => Beacon) private templateIdToBeacon;\n    mapping(bytes32 => bytes32) private requestIdToTemplateId;\n\n    /// @param airnodeRrp_ Airnode RRP address\n    constructor(address airnodeRrp_) RrpRequester(airnodeRrp_) {}\n\n    /// @notice Called by the sponsor to set the update request permission\n    /// status of an account\n    /// @param updateRequester Update requester address\n    /// @param updatePermissionStatus Update permission status of the update\n    /// requester\n    function setUpdatePermissionStatus(\n        address updateRequester,\n        bool updatePermissionStatus\n    ) external override {\n        require(updateRequester != address(0), \"Update requester zero\");\n        sponsorToUpdateRequesterToPermissionStatus[msg.sender][\n            updateRequester\n        ] = updatePermissionStatus;\n        emit SetUpdatePermissionStatus(\n            msg.sender,\n            updateRequester,\n            updatePermissionStatus\n        );\n    }\n\n    /// @notice Called to request a beacon to be updated\n    /// @dev Anyone can request a beacon to be updated. This is because it is\n    /// assumed that a beacon update request is always desirable, and the\n    /// requester and sponsor will pay for the gas cost.\n    /// There are two requirements for this method to be called: (1) The\n    /// sponsor must call `setSponsorshipStatus()` of AirnodeRrp to sponsor\n    /// this RrpBeaconServer contract, (2) The sponsor must call\n    /// `setUpdatePermissionStatus()` of this RrpBeaconServer contract to give\n    /// request update permission to the caller of this method.\n    /// The template used here must specify a single point of data of type\n    /// `int256` to be returned because this is what `fulfill()` expects.\n    /// @param templateId Template ID of the beacon to be updated\n    /// @param sponsor Sponsor whose wallet will be used to fulfill this\n    /// request\n    /// @param sponsorWallet Sponsor wallet that will be used to fulfill this\n    /// request\n    function requestBeaconUpdate(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet\n    ) external override {\n        require(\n            sponsorToUpdateRequesterToPermissionStatus[sponsor][msg.sender],\n            \"Caller not permitted\"\n        );\n        bytes32 requestId = airnodeRrp.makeTemplateRequest(\n            templateId,\n            sponsor,\n            sponsorWallet,\n            address(this),\n            this.fulfill.selector,\n            \"\"\n        );\n        requestIdToTemplateId[requestId] = templateId;\n        emit RequestedBeaconUpdate(\n            templateId,\n            sponsor,\n            msg.sender,\n            requestId,\n            sponsorWallet\n        );\n    }\n\n    /// @notice Called by AirnodeRrp to fulfill the request\n    /// @dev It is assumed that the fulfillment will be made with a single\n    /// point of data of type `int256`\n    /// @param requestId ID of the request being fulfilled\n    /// @param statusCode Status code of the fulfillment\n    /// @param data Fulfillment data (a single `int256` encoded as `bytes`)\n    function fulfill(\n        bytes32 requestId,\n        uint256 statusCode,\n        bytes calldata data\n    ) external override onlyAirnodeRrp {\n        bytes32 templateId = requestIdToTemplateId[requestId];\n        require(templateId != bytes32(0), \"Request ID unknown\");\n        delete requestIdToTemplateId[requestId];\n        if (statusCode == 0) {\n            int256 decodedData = abi.decode(data, (int256));\n            require(\n                decodedData >= type(int224).min &&\n                    decodedData <= type(int224).max,\n                \"Value typecasting error\"\n            );\n            require(\n                block.timestamp <= type(uint32).max,\n                \"Timestamp typecasting error\"\n            );\n            templateIdToBeacon[templateId] = Beacon({\n                value: int224(decodedData),\n                timestamp: uint32(block.timestamp)\n            });\n            emit UpdatedBeacon(\n                templateId,\n                requestId,\n                int224(decodedData),\n                uint32(block.timestamp)\n            );\n        } else {\n            emit ErroredBeaconUpdate(templateId, requestId, statusCode);\n        }\n    }\n\n    /// @notice Called by an admin to extend the whitelist expiration of a user\n    /// for the beacon\n    /// @param templateId Template ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration(\n        bytes32 templateId,\n        address user,\n        uint64 expirationTimestamp\n    )\n        external\n        override\n        onlyWithRank(uint256(AdminRank.Admin))\n        onlyIfTimestampExtends(templateId, user, expirationTimestamp)\n    {\n        serviceIdToUserToWhitelistStatus[templateId][user]\n            .expirationTimestamp = expirationTimestamp;\n        emit ExtendedWhitelistExpiration(\n            templateId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called by a super admin to set the whitelisting expiration of a\n    /// user for the beacon\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param templateId Template ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration(\n        bytes32 templateId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(uint256(AdminRank.SuperAdmin)) {\n        serviceIdToUserToWhitelistStatus[templateId][user]\n            .expirationTimestamp = expirationTimestamp;\n        emit SetWhitelistExpiration(\n            templateId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called by a super admin to set the whitelist status of a user\n    /// past expiration for the beacon\n    /// @param templateId Template ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration(\n        bytes32 templateId,\n        address user,\n        bool status\n    ) external override onlyWithRank(uint256(AdminRank.SuperAdmin)) {\n        serviceIdToUserToWhitelistStatus[templateId][user]\n            .whitelistedPastExpiration = status;\n        emit SetWhitelistStatusPastExpiration(\n            templateId,\n            user,\n            msg.sender,\n            status\n        );\n    }\n\n    /// @notice Called to read the beacon\n    /// @dev The caller must be whitelisted\n    /// @param templateId Template ID whose beacon will be returned\n    /// @return value Beacon value\n    /// @return timestamp Beacon timestamp\n    function readBeacon(bytes32 templateId)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        require(\n            userCanReadBeacon(templateId, msg.sender),\n            \"Caller not whitelisted\"\n        );\n        Beacon storage beacon = templateIdToBeacon[templateId];\n        return (beacon.value, beacon.timestamp);\n    }\n\n    /// @notice Called to check if a user is whitelisted to read the beacon\n    /// @param templateId Template ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userCanReadBeacon(bytes32 templateId, address user)\n        public\n        view\n        override\n        returns (bool isWhitelisted)\n    {\n        return\n            userIsWhitelisted(templateId, user) ||\n            adminToRank[user] >= uint256(AdminRank.Admin) ||\n            user == metaAdmin;\n    }\n\n    /// @notice Called to get the detailed whitelist status of a user for the\n    /// beacon\n    /// @param templateId Template ID\n    /// @param user User address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    /// @return whitelistedPastExpiration Whitelist status that the user will\n    /// have past expiration\n    function templateIdToUserToWhitelistStatus(bytes32 templateId, address user)\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, bool whitelistedPastExpiration)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                templateId\n            ][user];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        whitelistedPastExpiration = whitelistStatus.whitelistedPastExpiration;\n    }\n}\n"
    },
    "contracts/adminnable/Whitelister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\n/// @title Contract where users are whitelisted for specific services (could be\n/// Airnode endpoints, dAPIs, beacons, etc.) until an expiration time or\n/// indefinitely\ncontract Whitelister {\n    struct WhitelistStatus {\n        uint64 expirationTimestamp;\n        bool whitelistedPastExpiration;\n    }\n\n    mapping(bytes32 => mapping(address => WhitelistStatus))\n        internal serviceIdToUserToWhitelistStatus;\n\n    /// @dev Reverts if the provided timestamp does not extend whitelist\n    /// expiration for the service–user pair\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    modifier onlyIfTimestampExtends(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) {\n        require(\n            expirationTimestamp >\n                serviceIdToUserToWhitelistStatus[serviceId][user]\n                    .expirationTimestamp,\n            \"Expiration not extended\"\n        );\n        _;\n    }\n\n    /// @notice Called internally to check if a user is whitelisted to use the\n    /// service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(bytes32 serviceId, address user)\n        internal\n        view\n        returns (bool isWhitelisted)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                serviceId\n            ][user];\n        return\n            whitelistStatus.whitelistedPastExpiration ||\n            whitelistStatus.expirationTimestamp > block.timestamp;\n    }\n}\n"
    },
    "contracts/rrp/requesters/RrpRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../interfaces/IAirnodeRrp.sol\";\n\n/// @title The contract to be inherited to make Airnode RRP requests\ncontract RrpRequester {\n    IAirnodeRrp public immutable airnodeRrp;\n\n    /// @dev Reverts if the caller is not the Airnode RRP contract.\n    /// Use it as a modifier for fulfill and error callback methods, but also\n    /// check `requestId`.\n    modifier onlyAirnodeRrp() {\n        require(msg.sender == address(airnodeRrp), \"Caller not Airnode RRP\");\n        _;\n    }\n\n    /// @dev Airnode RRP address is set at deployment and is immutable.\n    /// RrpRequester is made its own sponsor by default. RrpRequester can also\n    /// be sponsored by others and use these sponsorships while making\n    /// requests, i.e., using this default sponsorship is optional.\n    /// @param airnodeRrp_ Airnode RRP contract address\n    constructor(address airnodeRrp_) {\n        airnodeRrp = IAirnodeRrp(airnodeRrp_);\n        IAirnodeRrp(airnodeRrp_).setSponsorshipStatus(address(this), true);\n    }\n}\n"
    },
    "contracts/rrp/requesters/interfaces/IRrpBeaconServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../adminnable/interfaces/IAdminnable.sol\";\n\ninterface IRrpBeaconServer is IAdminnable {\n    event SetUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed updateRequester,\n        bool updatePermissionStatus\n    );\n\n    event RequestedBeaconUpdate(\n        bytes32 indexed templateId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address sponsorWallet\n    );\n\n    event UpdatedBeacon(\n        bytes32 indexed templateId,\n        bytes32 requestId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event ErroredBeaconUpdate(\n        bytes32 indexed templateId,\n        bytes32 requestId,\n        uint256 statusCode\n    );\n\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed templateId,\n        address indexed user,\n        address indexed admin,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed templateId,\n        address indexed user,\n        address indexed admin,\n        uint256 expiration\n    );\n\n    event SetWhitelistStatusPastExpiration(\n        bytes32 indexed templateId,\n        address indexed user,\n        address indexed admin,\n        bool status\n    );\n\n    function setUpdatePermissionStatus(\n        address updateRequester,\n        bool updatePermissionStatus\n    ) external;\n\n    function requestBeaconUpdate(\n        bytes32 templateId,\n        address requester,\n        address designatedWallet\n    ) external;\n\n    function fulfill(\n        bytes32 requestId,\n        uint256 statusCode,\n        bytes calldata data\n    ) external;\n\n    function extendWhitelistExpiration(\n        bytes32 templateId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 templateId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistStatusPastExpiration(\n        bytes32 templateId,\n        address user,\n        bool status\n    ) external;\n\n    function readBeacon(bytes32 templateId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function userCanReadBeacon(bytes32 templateId, address user)\n        external\n        view\n        returns (bool isWhitelisted);\n\n    function templateIdToUserToWhitelistStatus(bytes32 templateId, address user)\n        external\n        view\n        returns (uint64 expirationTimestamp, bool whitelistedPastExpiration);\n\n    function sponsorToUpdateRequesterToPermissionStatus(\n        address sponsor,\n        address updateRequester\n    ) external view returns (bool permissionStatus);\n}\n"
    },
    "contracts/rrp/interfaces/IAirnodeRrp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IAuthorizationUtils.sol\";\nimport \"./ITemplateUtils.sol\";\nimport \"./IWithdrawalUtils.sol\";\n\ninterface IAirnodeRrp is IAuthorizationUtils, ITemplateUtils, IWithdrawalUtils {\n    event SetAirnodeXpub(address indexed airnode, string xpub);\n\n    event SetSponsorshipStatus(\n        address indexed sponsor,\n        address indexed requester,\n        bool sponsorshipStatus\n    );\n\n    event MadeTemplateRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event MadeFullRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event FulfilledRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 statusCode,\n        bytes data\n    );\n\n    event FailedRequest(address indexed airnode, bytes32 indexed requestId);\n\n    function setAirnodeXpub(string calldata xpub) external;\n\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external;\n\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        uint256 statusCode,\n        bytes calldata data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n    ) external;\n\n    function airnodeToXpub(address airnode)\n        external\n        view\n        returns (string memory xpub);\n\n    function sponsorToRequesterToSponsorshipStatus(\n        address sponsor,\n        address requester\n    ) external view returns (bool sponsorshipStatus);\n\n    function requesterToRequestCountPlusOne(address requester)\n        external\n        view\n        returns (uint256 requestCountPlusOne);\n\n    function requestWithIdHasFailed(bytes32 requestId)\n        external\n        view\n        returns (bool hasFailed);\n}\n"
    },
    "contracts/rrp/interfaces/IAuthorizationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAuthorizationUtils {\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool status);\n\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view returns (bool[] memory statuses);\n}\n"
    },
    "contracts/rrp/interfaces/ITemplateUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface ITemplateUtils {\n    event CreatedTemplate(\n        bytes32 indexed templateId,\n        address airnode,\n        bytes32 endpointId,\n        bytes parameters\n    );\n\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external returns (bytes32 templateId);\n\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        );\n\n    function templates(bytes32 templateId)\n        external\n        view\n        returns (\n            address airnode,\n            bytes32 endpointId,\n            bytes memory parameters\n        );\n}\n"
    },
    "contracts/rrp/interfaces/IWithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IWithdrawalUtils {\n    event RequestedWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet\n    );\n\n    event FulfilledWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet,\n        uint256 amount\n    );\n\n    function requestWithdrawal(address airnode, address sponsorWallet) external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable;\n\n    function sponsorToWithdrawalRequestCount(address sponsor)\n        external\n        view\n        returns (uint256 withdrawalRequestCount);\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IDaoRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../adminnable/interfaces/IAdminnable.sol\";\nimport \"./IRequesterRrpAuthorizer.sol\";\n\ninterface IDaoRequesterRrpAuthorizer is IAdminnable, IRequesterRrpAuthorizer {}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IRrpAuthorizer.sol\";\n\ninterface IRequesterRrpAuthorizer is IRrpAuthorizer {\n    event ExtendedWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed user,\n        address indexed admin,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed user,\n        address indexed admin,\n        uint256 expiration\n    );\n\n    event SetWhitelistStatusPastExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed user,\n        address indexed admin,\n        bool status\n    );\n\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistStatusPastExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) external;\n\n    function userIsWhitelisted(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    ) external view returns (bool isWhitelisted);\n\n    function airnodeToEndpointIdToUserToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, bool whitelistedPastExpiration);\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IRrpAuthorizer {\n    // solhint-disable-next-line func-name-mixedcase\n    function AUTHORIZER_TYPE() external view returns (uint256);\n\n    function isAuthorized(\n        bytes32 requestId,\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IAirnodeRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../adminnable/interfaces/ISelfAdminnable.sol\";\nimport \"./IRequesterRrpAuthorizer.sol\";\n\ninterface IAirnodeRequesterRrpAuthorizer is\n    ISelfAdminnable,\n    IRequesterRrpAuthorizer\n{}\n"
    },
    "contracts/adminnable/interfaces/ISelfAdminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface ISelfAdminnable {\n    event SetRank(\n        address indexed adminned,\n        address indexed callerAdmin,\n        address indexed targetAdmin,\n        uint256 newRank\n    );\n\n    event DecreasedSelfRank(\n        address indexed adminned,\n        address indexed admin,\n        uint256 newRank\n    );\n\n    function setRank(\n        address adminned,\n        address targetAdmin,\n        uint256 newRank\n    ) external;\n\n    function decreaseSelfRank(address adminned, uint256 newRank) external;\n\n    function adminnedToAdminToRank(address adminned, address admin)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/adminnable/SelfAdminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/ISelfAdminnable.sol\";\n\n/// @title Contract that implements multiple levels of admins for multiple\n/// \"adminned\" addresses independently\ncontract SelfAdminnable is ISelfAdminnable {\n    /// @notice Called to get the rank of an admin for the adminned address\n    mapping(address => mapping(address => uint256))\n        public\n        override adminnedToAdminToRank;\n\n    /// @dev Reverts if the caller's rank is not greater than or equal to\n    /// `rank` for the adminned address\n    /// @dev Adminned address always satisfies rank requirements\n    /// @param adminned Adminned address\n    /// @param rank Rank caller's rank will be compared to\n    modifier onlyWithRank(address adminned, uint256 rank) {\n        require(\n            adminnedToAdminToRank[adminned][msg.sender] >= rank ||\n                msg.sender == adminned,\n            \"Caller ranked low\"\n        );\n        _;\n    }\n\n    /// @notice Called by an admin of higher rank to set the rank of an admin\n    /// of lower rank for the adminned address\n    /// @param adminned Adminned address\n    /// @param targetAdmin Target admin address\n    /// @param newRank Rank to be set\n    function setRank(\n        address adminned,\n        address targetAdmin,\n        uint256 newRank\n    )\n        external\n        override\n        onlyWithRank(\n            adminned,\n            max(adminnedToAdminToRank[adminned][targetAdmin], newRank) + 1\n        )\n    {\n        require(targetAdmin != address(0), \"Target admin zero\");\n        adminnedToAdminToRank[adminned][targetAdmin] = newRank;\n        emit SetRank(adminned, msg.sender, targetAdmin, newRank);\n    }\n\n    /// @notice Called by an admin to decrease its rank for the adminned\n    /// address\n    /// @param adminned Adminned address\n    /// @param newRank Rank to be set\n    function decreaseSelfRank(address adminned, uint256 newRank)\n        external\n        override\n        onlyWithRank(adminned, newRank + 1)\n    {\n        adminnedToAdminToRank[adminned][msg.sender] = newRank;\n        emit DecreasedSelfRank(adminned, msg.sender, newRank);\n    }\n\n    /// @notice Called internally to compute the maximum between two unsigned\n    /// integers\n    /// @param a First unsigned integer\n    /// @param b Second unsigned integer\n    /// @return Larger of the two unsigned integers\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/AirnodeRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/SelfAdminnable.sol\";\nimport \"./RequesterRrpAuthorizer.sol\";\nimport \"./interfaces/IAirnodeRequesterRrpAuthorizer.sol\";\n\n/// @title Authorizer contract that whitelists requesters where each Airnode is\n/// adminned by themselves\n/// @dev The Airnode address and the admins are also authorized even if they\n/// are not whitelisted explicitly\ncontract AirnodeRequesterRrpAuthorizer is\n    SelfAdminnable,\n    RequesterRrpAuthorizer,\n    IAirnodeRequesterRrpAuthorizer\n{\n    enum AdminRank {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n    }\n\n    /// @notice Authorizer contracts use `AUTHORIZER_TYPE` to signal their type\n    uint256 public constant override AUTHORIZER_TYPE = 1;\n\n    /// @notice Called by an admin to extend the whitelist expiration of a user\n    /// for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(airnode, uint256(AdminRank.Admin)) {\n        extendWhitelistExpiration_(\n            airnode,\n            endpointId,\n            user,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called by a super admin to set the whitelisting expiration of a\n    /// user for the Airnode–endpoint pair\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(airnode, uint256(AdminRank.SuperAdmin)) {\n        setWhitelistExpiration_(airnode, endpointId, user, expirationTimestamp);\n    }\n\n    /// @notice Called by a super admin to set the whitelist status of a user\n    /// past expiration for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) external override onlyWithRank(airnode, uint256(AdminRank.SuperAdmin)) {\n        setWhitelistStatusPastExpiration_(airnode, endpointId, user, status);\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(\n                deriveServiceId(airnode, endpointId),\n                requester\n            ) ||\n            adminnedToAdminToRank[airnode][requester] >=\n            uint256(AdminRank.Admin) ||\n            requester == airnode;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/RequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/Whitelister.sol\";\nimport \"./interfaces/IRequesterRrpAuthorizer.sol\";\n\n/// @title Authorizer contract where requesters are whitelisted until an\n/// expiration time or indefinitely\nabstract contract RequesterRrpAuthorizer is\n    Whitelister,\n    IRequesterRrpAuthorizer\n{\n    /// @notice Called to check if a user is whitelisted to use the\n    /// Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    ) external view override returns (bool isWhitelisted) {\n        return userIsWhitelisted(deriveServiceId(airnode, endpointId), user);\n    }\n\n    /// @notice Called to get the detailed whitelist status of a user for the\n    /// Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    /// @return whitelistedPastExpiration Whitelist status that the user will\n    /// have past expiration\n    function airnodeToEndpointIdToUserToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, bool whitelistedPastExpiration)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                deriveServiceId(airnode, endpointId)\n            ][user];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        whitelistedPastExpiration = whitelistStatus.whitelistedPastExpiration;\n    }\n\n    /// @notice Called internally to derive the service ID of the\n    /// Airnode–endpoint pair\n    /// @dev Whitelister contract that this contract inherits keeps whitelist\n    /// statuses in a single level hash map. We have two parameters here\n    /// (Airnode address and endpoint ID) from which we need to derive a single\n    /// service ID, and we do this by calculating their hash.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @return serviceId Service ID\n    function deriveServiceId(address airnode, bytes32 endpointId)\n        internal\n        pure\n        returns (bytes32 serviceId)\n    {\n        return keccak256(abi.encodePacked(airnode, endpointId));\n    }\n\n    /// @notice Called internally to extend the whitelist expiration of a user\n    /// for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration_(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    )\n        internal\n        onlyIfTimestampExtends(\n            deriveServiceId(airnode, endpointId),\n            user,\n            expirationTimestamp\n        )\n    {\n        serviceIdToUserToWhitelistStatus[deriveServiceId(airnode, endpointId)][\n            user\n        ].expirationTimestamp = expirationTimestamp;\n        emit ExtendedWhitelistExpiration(\n            airnode,\n            endpointId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called internally to set the whitelisting expiration of a\n    /// user for the Airnode–endpoint pair\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration_(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        serviceIdToUserToWhitelistStatus[deriveServiceId(airnode, endpointId)][\n            user\n        ].expirationTimestamp = expirationTimestamp;\n        emit SetWhitelistExpiration(\n            airnode,\n            endpointId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called internally to set the whitelist status of a user\n    /// past expiration for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration_(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) internal {\n        serviceIdToUserToWhitelistStatus[deriveServiceId(airnode, endpointId)][\n            user\n        ].whitelistedPastExpiration = status;\n        emit SetWhitelistStatusPastExpiration(\n            airnode,\n            endpointId,\n            user,\n            msg.sender,\n            status\n        );\n    }\n}\n"
    },
    "contracts/rrp/authorizers/DaoRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/Adminnable.sol\";\nimport \"./RequesterRrpAuthorizer.sol\";\nimport \"./interfaces/IDaoRequesterRrpAuthorizer.sol\";\n\n/// @title Authorizer contract that whitelists requesters where the API3 DAO is\n/// the meta-admin\n/// @dev The meta-admin and the admins are also authorized even if they\n/// are not whitelisted explicitly\ncontract DaoRequesterRrpAuthorizer is\n    Adminnable,\n    RequesterRrpAuthorizer,\n    IDaoRequesterRrpAuthorizer\n{\n    enum AdminRank {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n    }\n\n    /// @notice Authorizer contracts use `AUTHORIZER_TYPE` to signal their type\n    uint256 public constant override AUTHORIZER_TYPE = 2;\n\n    /// @notice Called by an admin to extend the whitelist expiration of a user\n    /// for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(uint256(AdminRank.Admin)) {\n        extendWhitelistExpiration_(\n            airnode,\n            endpointId,\n            user,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called by a super admin to set the whitelisting expiration of a\n    /// user for the Airnode–endpoint pair\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(uint256(AdminRank.SuperAdmin)) {\n        setWhitelistExpiration_(airnode, endpointId, user, expirationTimestamp);\n    }\n\n    /// @notice Called by a super admin to set the whitelist status of a user\n    /// past expiration for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) external override onlyWithRank(uint256(AdminRank.SuperAdmin)) {\n        setWhitelistStatusPastExpiration_(airnode, endpointId, user, status);\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(\n                deriveServiceId(airnode, endpointId),\n                requester\n            ) ||\n            adminToRank[requester] >= uint256(AdminRank.Admin) ||\n            requester == metaAdmin;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/mock/MockRrpAuthorizerAlwaysTrue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../interfaces/IRrpAuthorizer.sol\";\n\n/// @title A mock authorizer that always returns true\ncontract MockRrpAuthorizerAlwaysTrue is IRrpAuthorizer {\n    uint256 public constant override AUTHORIZER_TYPE = 333;\n\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line\n        address airnode, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        address sponsor, // solhint-disable-line\n        address requester // solhint-disable-line\n    ) external view virtual override returns (bool status) {\n        status = true;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/mock/MockRrpAuthorizerAlwaysFalse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../interfaces/IRrpAuthorizer.sol\";\n\n/// @title A mock authorizer that always returns false\ncontract MockRrpAuthorizerAlwaysFalse is IRrpAuthorizer {\n    uint256 public constant override AUTHORIZER_TYPE = 333;\n\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line\n        address airnode, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        address sponsor, // solhint-disable-line\n        address requester // solhint-disable-line\n    ) external view virtual override returns (bool status) {\n        status = false;\n    }\n}\n"
    },
    "contracts/rrp/AuthorizationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IAuthorizationUtils.sol\";\nimport \"./authorizers/interfaces/IRrpAuthorizer.sol\";\n\n/// @title Contract that implements convenience functions\ncontract AuthorizationUtils is IAuthorizationUtils {\n    /// @notice Uses the authorizer contracts of an Airnode to decide if a\n    /// request is authorized. Once an Airnode receives a request, it calls\n    /// this method to determine if it should respond. Similarly, third parties\n    /// can use this method to determine if a particular request would be\n    /// authorized.\n    /// @dev This method is meant to be called off-chain, statically by the\n    /// Airnode to decide if it should respond to a request. The requester can\n    /// also call it, yet this function returning true should not be taken as a\n    /// guarantee of the subsequent request being fulfilled.\n    /// It is enough for only one of the authorizer contracts to return true\n    /// for the request to be authorized.\n    /// @param authorizers Authorizer contract addresses\n    /// @param airnode Airnode address\n    /// @param requestId Request ID\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return status Authorization status of the request\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) public view override returns (bool status) {\n        for (uint256 ind = 0; ind < authorizers.length; ind++) {\n            IRrpAuthorizer authorizer = IRrpAuthorizer(authorizers[ind]);\n            if (\n                authorizer.isAuthorized(\n                    requestId,\n                    airnode,\n                    endpointId,\n                    sponsor,\n                    requester\n                )\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice A convenience function to make multiple authorization status\n    /// checks with a single call\n    /// @param airnode Airnode address\n    /// @param requestIds Request IDs\n    /// @param endpointIds Endpoint IDs\n    /// @param sponsors Sponsor addresses\n    /// @param requesters Requester addresses\n    /// @return statuses Authorization statuses of the request\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view override returns (bool[] memory statuses) {\n        require(\n            requestIds.length == endpointIds.length &&\n                requestIds.length == sponsors.length &&\n                requestIds.length == requesters.length,\n            \"Unequal parameter lengths\"\n        );\n        statuses = new bool[](requestIds.length);\n        for (uint256 ind = 0; ind < requestIds.length; ind++) {\n            statuses[ind] = checkAuthorizationStatus(\n                authorizers,\n                airnode,\n                requestIds[ind],\n                endpointIds[ind],\n                sponsors[ind],\n                requesters[ind]\n            );\n        }\n    }\n}\n"
    },
    "contracts/rrp/requesters/mock/MockRrpRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../RrpRequester.sol\";\n\n/// @title A mock Airnode RRP requester contract\ncontract MockRrpRequester is RrpRequester {\n    event FulfilledRequest(\n        bytes32 indexed requestId,\n        uint256 statusCode,\n        bytes data\n    );\n\n    mapping(bytes32 => uint256) public requestIdToStatusCode;\n    mapping(bytes32 => bytes) public requestIdToData;\n\n    mapping(bytes32 => bool) private expectingRequestWithIdToBeFulfilled;\n\n    /// @param airnodeRrpAddress Airnode RRP contract address\n    constructor(address airnodeRrpAddress) RrpRequester(airnodeRrpAddress) {}\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external {\n        bytes32 requestId = airnodeRrp.makeTemplateRequest(\n            templateId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external {\n        bytes32 requestId = airnodeRrp.makeFullRequest(\n            airnode,\n            endpointId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing\n    /// @param requestId Request ID\n    /// @param statusCode Status code returned by the Airnode\n    /// @param data Data returned by the Airnode\n    function fulfill(\n        bytes32 requestId,\n        uint256 statusCode,\n        bytes calldata data\n    ) external onlyAirnodeRrp {\n        require(\n            expectingRequestWithIdToBeFulfilled[requestId],\n            \"No such request made\"\n        );\n        delete expectingRequestWithIdToBeFulfilled[requestId];\n        requestIdToStatusCode[requestId] = statusCode;\n        requestIdToData[requestId] = data;\n        emit FulfilledRequest(requestId, statusCode, data);\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param statusCode Status code returned by the Airnode\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysReverts(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        uint256 statusCode, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        revert(\"Always reverts\");\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment running out of gas\n    /// @param requestId Request ID\n    /// @param statusCode Status code returned by the Airnode\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysRunsOutOfGas(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        uint256 statusCode, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        while (true) {}\n    }\n}\n"
    },
    "contracts/rrp/WithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IWithdrawalUtils.sol\";\n\n/// @title Contract that implements logic for withdrawals from sponsor wallets\ncontract WithdrawalUtils is IWithdrawalUtils {\n    /// @notice Called to get the withdrawal request count of the sponsor\n    /// @dev Can be used to calculate the ID of the next withdrawal request the\n    /// sponsor will make\n    mapping(address => uint256) public override sponsorToWithdrawalRequestCount;\n\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\n    /// the fulfillment will be done with the correct parameters\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\n\n    /// @notice Called by a sponsor to create a request for the Airnode to send\n    /// the funds kept in the respective sponsor wallet to the sponsor\n    /// @dev We do not need to use the withdrawal request parameters in the\n    /// request ID hash to validate them at the node-side because all of the\n    /// parameters are used during fulfillment and will get validated on-chain\n    /// @param airnode Airnode address\n    /// @param sponsorWallet Sponsor wallet\n    function requestWithdrawal(address airnode, address sponsorWallet)\n        external\n        override\n    {\n        bytes32 withdrawalRequestId = keccak256(\n            abi.encodePacked(\n                ++sponsorToWithdrawalRequestCount[msg.sender],\n                block.chainid,\n                msg.sender\n            )\n        );\n        withdrawalRequestIdToParameters[withdrawalRequestId] = keccak256(\n            abi.encodePacked(airnode, msg.sender, sponsorWallet)\n        );\n        emit RequestedWithdrawal(\n            airnode,\n            msg.sender,\n            withdrawalRequestId,\n            sponsorWallet\n        );\n    }\n\n    /// @notice Called by the Airnode using the sponsor wallet to fulfill the\n    /// withdrawal request made by the sponsor\n    /// @dev The Airnode sends the funds to the sponsor through this method\n    /// to emit an event that indicates that the withdrawal request has been\n    /// fulfilled\n    /// @param withdrawalRequestId Withdrawal request ID\n    /// @param airnode Airnode address\n    /// @param sponsor Sponsor address\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable override {\n        require(\n            withdrawalRequestIdToParameters[withdrawalRequestId] ==\n                keccak256(abi.encodePacked(airnode, sponsor, msg.sender)),\n            \"Invalid withdrawal fulfillment\"\n        );\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\n        emit FulfilledWithdrawal(\n            airnode,\n            sponsor,\n            withdrawalRequestId,\n            msg.sender,\n            msg.value\n        );\n        (bool success, ) = sponsor.call{value: msg.value}(\"\"); // solhint-disable-line avoid-low-level-calls\n        require(success, \"Transfer failed\");\n    }\n}\n"
    },
    "contracts/rrp/AirnodeRrp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./AuthorizationUtils.sol\";\nimport \"./TemplateUtils.sol\";\nimport \"./WithdrawalUtils.sol\";\nimport \"./interfaces/IAirnodeRrp.sol\";\n\n/// @title Contract that implements the Airnode request–response protocol (RRP)\ncontract AirnodeRrp is\n    AuthorizationUtils,\n    TemplateUtils,\n    WithdrawalUtils,\n    IAirnodeRrp\n{\n    /// @notice Called to get the extended public key of the Airnode\n    mapping(address => string) public override airnodeToXpub;\n\n    /// @notice Called to get the sponsorship status for a sponsor–requester\n    /// pair\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToRequesterToSponsorshipStatus;\n\n    /// @notice Called to get the request count of the requester plus one\n    /// @dev Can be used to calculate the ID of the next request the requester\n    /// will make\n    mapping(address => uint256) public override requesterToRequestCountPlusOne;\n\n    /// @notice Called to check if the fulfillment of a request has failed\n    /// @dev Requests will be marked to have failed by the respective Airnode\n    /// if the fulfillment call will revert\n    mapping(bytes32 => bool) public override requestWithIdHasFailed;\n\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\n    /// the fulfillment will be done with the correct parameters\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\n\n    /// @dev Reverts if the incoming fulfillment parameters do not match the\n    /// ones provided in the request\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    modifier onlyCorrectFulfillmentParameters(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n    ) {\n        require(\n            keccak256(\n                abi.encodePacked(\n                    airnode,\n                    msg.sender,\n                    fulfillAddress,\n                    fulfillFunctionId\n                )\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        _;\n    }\n\n    /// @notice Called by the Airnode operator to announce its extended public\n    /// key\n    /// @dev It is expected for the Airnode operator to call this function with\n    /// the respective Airnode's default BIP 44 wallet (m/44'/60'/0'/0/0).\n    /// Correspondingly, if the address of the default BIP 44 wallet derived\n    /// from the extended public key does not match the respective Airnode\n    /// address, the extended public key is invalid (does not belong to the\n    /// respective Airnode).\n    /// An Airnode operator can also announce their extended public key through\n    /// off-chain channels. Validation method remains the same.\n    /// The extended public key of an Airnode is used with a sponsor address to\n    /// derive the address of the respective sponsor wallet.\n    /// @param xpub Extended public key of the Airnode\n    function setAirnodeXpub(string calldata xpub) external override {\n        airnodeToXpub[msg.sender] = xpub;\n        emit SetAirnodeXpub(msg.sender, xpub);\n    }\n\n    /// @notice Called by the sponsor to set the sponsorship status of a\n    /// requester, i.e., allow or disallow a requester to make requests that\n    /// will be fulfilled by the sponsor wallet\n    /// @dev This is not Airnode-specific, i.e., the sponsor allows the\n    /// requester's requests to be fulfilled through its sponsor wallets across\n    /// all Airnodes\n    /// @param requester Requester address\n    /// @param sponsorshipStatus Sponsorship status\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external\n        override\n    {\n        // Initialize the requester request count for consistent request gas\n        // cost\n        if (requesterToRequestCountPlusOne[requester] == 0) {\n            requesterToRequestCountPlusOne[requester] = 1;\n        }\n        sponsorToRequesterToSponsorshipStatus[msg.sender][\n            requester\n        ] = sponsorshipStatus;\n        emit SetSponsorshipStatus(msg.sender, requester, sponsorshipStatus);\n    }\n\n    /// @notice Called by the requester to make a request that refers to a\n    /// template for the Airnode address, endpoint ID and parameters\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill the\n    /// request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    /// @return requestId Request ID\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external override returns (bytes32 requestId) {\n        address airnode = templates[templateId].airnode;\n        require(airnode != address(0), \"Template does not exist\");\n        require(fulfillAddress != address(this), \"Fulfill address AirnodeRrp\");\n        require(\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\n            \"Requester not sponsored\"\n        );\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\n            msg.sender\n        ];\n        requestId = keccak256(\n            abi.encodePacked(\n                requesterRequestCount,\n                block.chainid,\n                msg.sender,\n                templateId,\n                sponsor,\n                parameters\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(\n                airnode,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId\n            )\n        );\n        emit MadeTemplateRequest(\n            airnode,\n            requestId,\n            requesterRequestCount,\n            block.chainid,\n            msg.sender,\n            templateId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        requesterToRequestCountPlusOne[msg.sender]++;\n    }\n\n    /// @notice Called by the requester to make a full request, which provides\n    /// all of its parameters as arguments and does not refer to a template\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    /// @return requestId Request ID\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external override returns (bytes32 requestId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(fulfillAddress != address(this), \"Fulfill address AirnodeRrp\");\n        require(\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\n            \"Requester not sponsored\"\n        );\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\n            msg.sender\n        ];\n        requestId = keccak256(\n            abi.encodePacked(\n                requesterRequestCount,\n                block.chainid,\n                msg.sender,\n                endpointId,\n                sponsor,\n                parameters\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(\n                airnode,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId\n            )\n        );\n        requesterToRequestCountPlusOne[msg.sender]++;\n        emit MadeFullRequest(\n            airnode,\n            requestId,\n            requesterRequestCount,\n            block.chainid,\n            msg.sender,\n            endpointId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by Airnode to fulfill the request (template or full)\n    /// @dev `statusCode` being zero indicates a successful fulfillment, while\n    /// non-zero values indicate error. The meaning of these values are\n    /// implementation-dependent.\n    /// The data is ABI-encoded as a `bytes` type, with its format depending on\n    /// the request specifications.\n    /// This method will revert if the targeted function reverts or no function\n    /// with the matching signature is found. It will succeed if the targeted\n    /// function or the targeted address does not belong to a contract.\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param statusCode Status code of the fulfillment\n    /// @param data Fulfillment data\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        uint256 statusCode,\n        bytes calldata data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n    )\n        external\n        override\n        onlyCorrectFulfillmentParameters(\n            requestId,\n            airnode,\n            fulfillAddress,\n            fulfillFunctionId\n        )\n        returns (bool callSuccess, bytes memory callData)\n    {\n        delete requestIdToFulfillmentParameters[requestId];\n        emit FulfilledRequest(airnode, requestId, statusCode, data);\n        (callSuccess, callData) = fulfillAddress.call( // solhint-disable-line avoid-low-level-calls\n            abi.encodeWithSelector(\n                fulfillFunctionId,\n                requestId,\n                statusCode,\n                data\n            )\n        );\n        require(callSuccess, \"Fulfillment failed\");\n    }\n\n    /// @notice Called by Airnode if the request cannot be fulfilled\n    /// @dev Airnode should fall back to this if a request cannot be fulfilled\n    /// because fulfill() reverts\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n    )\n        external\n        override\n        onlyCorrectFulfillmentParameters(\n            requestId,\n            airnode,\n            fulfillAddress,\n            fulfillFunctionId\n        )\n    {\n        delete requestIdToFulfillmentParameters[requestId];\n        // Failure is recorded so that it can be checked externally\n        requestWithIdHasFailed[requestId] = true;\n        emit FailedRequest(airnode, requestId);\n    }\n}\n"
    },
    "contracts/rrp/TemplateUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/ITemplateUtils.sol\";\n\n/// @title Contract that implements request template logic\ncontract TemplateUtils is ITemplateUtils {\n    struct Template {\n        address airnode;\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    /// @notice Called to get a template\n    mapping(bytes32 => Template) public override templates;\n\n    /// @notice Creates a request template with the given parameters,\n    /// addressable by the ID it returns\n    /// @dev A specific set of request parameters will always have the same ID.\n    /// This means a few things: (1) You can compute the expected ID of a\n    /// template before creating it, (2) Creating a new template with the same\n    /// parameters will overwrite the old one and return the same ID, (3) After\n    /// you query a template with its ID, you can verify its integrity by\n    /// applying the hash and comparing the result with the ID.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at request-time)\n    /// @return templateId Request template ID\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external override returns (bytes32 templateId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        templateId = keccak256(\n            abi.encodePacked(airnode, endpointId, parameters)\n        );\n        templates[templateId] = Template({\n            airnode: airnode,\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit CreatedTemplate(templateId, airnode, endpointId, parameters);\n    }\n\n    /// @notice A convenience method to retrieve multiple templates with a\n    /// single call\n    /// @dev Does not revert if the templates being indexed do not exist\n    /// @param templateIds Request template IDs\n    /// @return airnodes Array of Airnode addresses\n    /// @return endpointIds Array of endpoint IDs\n    /// @return parameters Array of request parameters\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        override\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        )\n    {\n        airnodes = new address[](templateIds.length);\n        endpointIds = new bytes32[](templateIds.length);\n        parameters = new bytes[](templateIds.length);\n        for (uint256 ind = 0; ind < templateIds.length; ind++) {\n            Template storage template = templates[templateIds[ind]];\n            airnodes[ind] = template.airnode;\n            endpointIds[ind] = template.endpointId;\n            parameters[ind] = template.parameters;\n        }\n    }\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IApi3Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IApi3Token is IERC20 {\n    function mint(address account, uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/rrp/authorizers/mock/Api3Token.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IApi3Token.sol\";\n\n/// @title API3 Mock token contract\n\ncontract Api3Token is ERC20, Ownable, IApi3Token {\n    /// @param contractOwner Address that will receive the ownership of the\n    /// token contract\n    /// @param mintingDestination Address that the tokens will be minted to\n    constructor(address contractOwner, address mintingDestination)\n        ERC20(\"API3\", \"API3\")\n    {\n        transferOwnership(contractOwner);\n        // Initial supply is 100 million (100e6)\n        // We are using ether because the token has 18 decimals like ETH\n        _mint(mintingDestination, 100e6 ether);\n    }\n\n    /// @notice Mints tokens\n    /// @param account Address that will receive the minted tokens\n    /// @param amount Amount that will be minted\n    function mint(address account, uint256 amount) external override {\n        _mint(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
